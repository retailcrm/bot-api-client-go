// Package bot_api_client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package bot_api_client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Bot_tokenScopes = "bot_token.Scopes"
)

// Defines values for ActorType.
const (
	ActorTypeBot      ActorType = "bot"
	ActorTypeChannel  ActorType = "channel"
	ActorTypeCustomer ActorType = "customer"
	ActorTypeUser     ActorType = "user"
)

// EnumValues returns all valid values for ActorType.
func (ActorType) EnumValues() []string {
	return []string{
		string(ActorTypeBot),
		string(ActorTypeChannel),
		string(ActorTypeCustomer),
		string(ActorTypeUser),
	}
}

// Validate validates the value of ActorType.
func (v ActorType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for ActorType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for ActorType.
func (v *ActorType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = ActorType(s)
	return nil
}

// Defines values for Boolean.
const (
	BooleanFalse Boolean = "false"
	BooleanN0    Boolean = "0"
	BooleanN1    Boolean = "1"
	BooleanTrue  Boolean = "true"
)

// EnumValues returns all valid values for Boolean.
func (Boolean) EnumValues() []string {
	return []string{
		string(BooleanFalse),
		string(BooleanN0),
		string(BooleanN1),
		string(BooleanTrue),
	}
}

// Validate validates the value of Boolean.
func (v Boolean) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for Boolean: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for Boolean.
func (v *Boolean) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = Boolean(s)
	return nil
}

// Defines values for ChannelFeature.
const (
	ChannelFeatureBoth    ChannelFeature = "both"
	ChannelFeatureNone    ChannelFeature = "none"
	ChannelFeatureReceive ChannelFeature = "receive"
	ChannelFeatureSend    ChannelFeature = "send"
)

// EnumValues returns all valid values for ChannelFeature.
func (ChannelFeature) EnumValues() []string {
	return []string{
		string(ChannelFeatureBoth),
		string(ChannelFeatureNone),
		string(ChannelFeatureReceive),
		string(ChannelFeatureSend),
	}
}

// Validate validates the value of ChannelFeature.
func (v ChannelFeature) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for ChannelFeature: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for ChannelFeature.
func (v *ChannelFeature) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = ChannelFeature(s)
	return nil
}

// Defines values for ChannelType.
const (
	ChannelTypeAvito         ChannelType = "avito"
	ChannelTypeConsultant    ChannelType = "consultant"
	ChannelTypeCustom        ChannelType = "custom"
	ChannelTypeDrom          ChannelType = "drom"
	ChannelTypeFbmessenger   ChannelType = "fbmessenger"
	ChannelTypeInstagram     ChannelType = "instagram"
	ChannelTypeMax           ChannelType = "max"
	ChannelTypeMegaMarket    ChannelType = "mega_market"
	ChannelTypeOdnoklassniki ChannelType = "odnoklassniki"
	ChannelTypeOzon          ChannelType = "ozon"
	ChannelTypeSkype         ChannelType = "skype"
	ChannelTypeTelegram      ChannelType = "telegram"
	ChannelTypeViber         ChannelType = "viber"
	ChannelTypeVk            ChannelType = "vk"
	ChannelTypeWhatsapp      ChannelType = "whatsapp"
	ChannelTypeWildberries   ChannelType = "wildberries"
	ChannelTypeYandexChat    ChannelType = "yandex_chat"
	ChannelTypeYandexMarket  ChannelType = "yandex_market"
	ChannelTypeYoula         ChannelType = "youla"
)

// EnumValues returns all valid values for ChannelType.
func (ChannelType) EnumValues() []string {
	return []string{
		string(ChannelTypeAvito),
		string(ChannelTypeConsultant),
		string(ChannelTypeCustom),
		string(ChannelTypeDrom),
		string(ChannelTypeFbmessenger),
		string(ChannelTypeInstagram),
		string(ChannelTypeMax),
		string(ChannelTypeMegaMarket),
		string(ChannelTypeOdnoklassniki),
		string(ChannelTypeOzon),
		string(ChannelTypeSkype),
		string(ChannelTypeTelegram),
		string(ChannelTypeViber),
		string(ChannelTypeVk),
		string(ChannelTypeWhatsapp),
		string(ChannelTypeWildberries),
		string(ChannelTypeYandexChat),
		string(ChannelTypeYandexMarket),
		string(ChannelTypeYoula),
	}
}

// Validate validates the value of ChannelType.
func (v ChannelType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for ChannelType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for ChannelType.
func (v *ChannelType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = ChannelType(s)
	return nil
}

// Defines values for ChatWaitingLevel.
const (
	ChatWaitingLevelDanger  ChatWaitingLevel = "danger"
	ChatWaitingLevelNone    ChatWaitingLevel = "none"
	ChatWaitingLevelWarning ChatWaitingLevel = "warning"
)

// EnumValues returns all valid values for ChatWaitingLevel.
func (ChatWaitingLevel) EnumValues() []string {
	return []string{
		string(ChatWaitingLevelDanger),
		string(ChatWaitingLevelNone),
		string(ChatWaitingLevelWarning),
	}
}

// Validate validates the value of ChatWaitingLevel.
func (v ChatWaitingLevel) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for ChatWaitingLevel: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for ChatWaitingLevel.
func (v *ChatWaitingLevel) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = ChatWaitingLevel(s)
	return nil
}

// Defines values for ChatMemberListResponseItemState.
const (
	ChatMemberListResponseItemStateActive ChatMemberListResponseItemState = "active"
	ChatMemberListResponseItemStateKicked ChatMemberListResponseItemState = "kicked"
	ChatMemberListResponseItemStateLeaved ChatMemberListResponseItemState = "leaved"
)

// EnumValues returns all valid values for ChatMemberListResponseItemState.
func (ChatMemberListResponseItemState) EnumValues() []string {
	return []string{
		string(ChatMemberListResponseItemStateActive),
		string(ChatMemberListResponseItemStateKicked),
		string(ChatMemberListResponseItemStateLeaved),
	}
}

// Validate validates the value of ChatMemberListResponseItemState.
func (v ChatMemberListResponseItemState) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for ChatMemberListResponseItemState: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for ChatMemberListResponseItemState.
func (v *ChatMemberListResponseItemState) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = ChatMemberListResponseItemState(s)
	return nil
}

// Defines values for ChatsListResponseItemWaitingLevel.
const (
	ChatsListResponseItemWaitingLevelDanger  ChatsListResponseItemWaitingLevel = "danger"
	ChatsListResponseItemWaitingLevelNone    ChatsListResponseItemWaitingLevel = "none"
	ChatsListResponseItemWaitingLevelWarning ChatsListResponseItemWaitingLevel = "warning"
)

// EnumValues returns all valid values for ChatsListResponseItemWaitingLevel.
func (ChatsListResponseItemWaitingLevel) EnumValues() []string {
	return []string{
		string(ChatsListResponseItemWaitingLevelDanger),
		string(ChatsListResponseItemWaitingLevelNone),
		string(ChatsListResponseItemWaitingLevelWarning),
	}
}

// Validate validates the value of ChatsListResponseItemWaitingLevel.
func (v ChatsListResponseItemWaitingLevel) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for ChatsListResponseItemWaitingLevel: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for ChatsListResponseItemWaitingLevel.
func (v *ChatsListResponseItemWaitingLevel) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = ChatsListResponseItemWaitingLevel(s)
	return nil
}

// Defines values for ColorCode.
const (
	ColorCodeBlue             ColorCode = "blue"
	ColorCodeGray             ColorCode = "gray"
	ColorCodeGrayishBlue      ColorCode = "grayish-blue"
	ColorCodeGreen            ColorCode = "green"
	ColorCodeLightBlue        ColorCode = "light-blue"
	ColorCodeLightGray        ColorCode = "light-gray"
	ColorCodeLightGrayishBlue ColorCode = "light-grayish-blue"
	ColorCodeLightGreen       ColorCode = "light-green"
	ColorCodeLightOrange      ColorCode = "light-orange"
	ColorCodeLightRed         ColorCode = "light-red"
	ColorCodeOrange           ColorCode = "orange"
	ColorCodeRed              ColorCode = "red"
)

// EnumValues returns all valid values for ColorCode.
func (ColorCode) EnumValues() []string {
	return []string{
		string(ColorCodeBlue),
		string(ColorCodeGray),
		string(ColorCodeGrayishBlue),
		string(ColorCodeGreen),
		string(ColorCodeLightBlue),
		string(ColorCodeLightGray),
		string(ColorCodeLightGrayishBlue),
		string(ColorCodeLightGreen),
		string(ColorCodeLightOrange),
		string(ColorCodeLightRed),
		string(ColorCodeOrange),
		string(ColorCodeRed),
	}
}

// Validate validates the value of ColorCode.
func (v ColorCode) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for ColorCode: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for ColorCode.
func (v *ColorCode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = ColorCode(s)
	return nil
}

// Defines values for CustomerExternalId.
const (
	CustomerExternalIdAny   CustomerExternalId = "any"
	CustomerExternalIdPhone CustomerExternalId = "phone"
)

// EnumValues returns all valid values for CustomerExternalId.
func (CustomerExternalId) EnumValues() []string {
	return []string{
		string(CustomerExternalIdAny),
		string(CustomerExternalIdPhone),
	}
}

// Validate validates the value of CustomerExternalId.
func (v CustomerExternalId) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for CustomerExternalId: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for CustomerExternalId.
func (v *CustomerExternalId) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = CustomerExternalId(s)
	return nil
}

// Defines values for FileTranscriptionStatus.
const (
	FileTranscriptionStatusError      FileTranscriptionStatus = "error"
	FileTranscriptionStatusInProgress FileTranscriptionStatus = "in_progress"
	FileTranscriptionStatusReady      FileTranscriptionStatus = "ready"
)

// EnumValues returns all valid values for FileTranscriptionStatus.
func (FileTranscriptionStatus) EnumValues() []string {
	return []string{
		string(FileTranscriptionStatusError),
		string(FileTranscriptionStatusInProgress),
		string(FileTranscriptionStatusReady),
	}
}

// Validate validates the value of FileTranscriptionStatus.
func (v FileTranscriptionStatus) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for FileTranscriptionStatus: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for FileTranscriptionStatus.
func (v *FileTranscriptionStatus) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = FileTranscriptionStatus(s)
	return nil
}

// Defines values for FileType.
const (
	FileTypeAudio FileType = "audio"
	FileTypeFile  FileType = "file"
	FileTypeImage FileType = "image"
	FileTypeNone  FileType = "none"
	FileTypeVideo FileType = "video"
)

// EnumValues returns all valid values for FileType.
func (FileType) EnumValues() []string {
	return []string{
		string(FileTypeAudio),
		string(FileTypeFile),
		string(FileTypeImage),
		string(FileTypeNone),
		string(FileTypeVideo),
	}
}

// Validate validates the value of FileType.
func (v FileType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for FileType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for FileType.
func (v *FileType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = FileType(s)
	return nil
}

// Defines values for MemberState.
const (
	MemberStateActive    MemberState = "active"
	MemberStateKicked    MemberState = "kicked"
	MemberStateLeaved    MemberState = "leaved"
	MemberStateUndefined MemberState = "undefined"
)

// EnumValues returns all valid values for MemberState.
func (MemberState) EnumValues() []string {
	return []string{
		string(MemberStateActive),
		string(MemberStateKicked),
		string(MemberStateLeaved),
		string(MemberStateUndefined),
	}
}

// Validate validates the value of MemberState.
func (v MemberState) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MemberState: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MemberState.
func (v *MemberState) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MemberState(s)
	return nil
}

// Defines values for MessageAction.
const (
	MessageActionDelete MessageAction = "delete"
	MessageActionEdit   MessageAction = "edit"
	MessageActionQuote  MessageAction = "quote"
)

// EnumValues returns all valid values for MessageAction.
func (MessageAction) EnumValues() []string {
	return []string{
		string(MessageActionDelete),
		string(MessageActionEdit),
		string(MessageActionQuote),
	}
}

// Validate validates the value of MessageAction.
func (v MessageAction) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MessageAction: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MessageAction.
func (v *MessageAction) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MessageAction(s)
	return nil
}

// Defines values for MessageErrorCode.
const (
	MessageErrorCodeAccessRestricted  MessageErrorCode = "access_restricted"
	MessageErrorCodeAsyncSendTimeout  MessageErrorCode = "async_send_timeout"
	MessageErrorCodeCustomerNotExists MessageErrorCode = "customer_not_exists"
	MessageErrorCodeGeneral           MessageErrorCode = "general"
	MessageErrorCodeMalformedResponse MessageErrorCode = "malformed_response"
	MessageErrorCodeNetworkError      MessageErrorCode = "network_error"
	MessageErrorCodeReplyTimedOut     MessageErrorCode = "reply_timed_out"
	MessageErrorCodeSpamSuspicion     MessageErrorCode = "spam_suspicion"
	MessageErrorCodeUnknown           MessageErrorCode = "unknown"
)

// EnumValues returns all valid values for MessageErrorCode.
func (MessageErrorCode) EnumValues() []string {
	return []string{
		string(MessageErrorCodeAccessRestricted),
		string(MessageErrorCodeAsyncSendTimeout),
		string(MessageErrorCodeCustomerNotExists),
		string(MessageErrorCodeGeneral),
		string(MessageErrorCodeMalformedResponse),
		string(MessageErrorCodeNetworkError),
		string(MessageErrorCodeReplyTimedOut),
		string(MessageErrorCodeSpamSuspicion),
		string(MessageErrorCodeUnknown),
	}
}

// Validate validates the value of MessageErrorCode.
func (v MessageErrorCode) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MessageErrorCode: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MessageErrorCode.
func (v *MessageErrorCode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MessageErrorCode(s)
	return nil
}

// Defines values for MessageOrderStatusCode.
const (
	MessageOrderStatusCodeApproval   MessageOrderStatusCode = "approval"
	MessageOrderStatusCodeAssembling MessageOrderStatusCode = "assembling"
	MessageOrderStatusCodeCancel     MessageOrderStatusCode = "cancel"
	MessageOrderStatusCodeComplete   MessageOrderStatusCode = "complete"
	MessageOrderStatusCodeDelivery   MessageOrderStatusCode = "delivery"
	MessageOrderStatusCodeNew        MessageOrderStatusCode = "new"
)

// EnumValues returns all valid values for MessageOrderStatusCode.
func (MessageOrderStatusCode) EnumValues() []string {
	return []string{
		string(MessageOrderStatusCodeApproval),
		string(MessageOrderStatusCodeAssembling),
		string(MessageOrderStatusCodeCancel),
		string(MessageOrderStatusCodeComplete),
		string(MessageOrderStatusCodeDelivery),
		string(MessageOrderStatusCodeNew),
	}
}

// Validate validates the value of MessageOrderStatusCode.
func (v MessageOrderStatusCode) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MessageOrderStatusCode: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MessageOrderStatusCode.
func (v *MessageOrderStatusCode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MessageOrderStatusCode(s)
	return nil
}

// Defines values for MessageScope.
const (
	MessageScopePrivate   MessageScope = "private"
	MessageScopePublic    MessageScope = "public"
	MessageScopeUndefined MessageScope = "undefined"
)

// EnumValues returns all valid values for MessageScope.
func (MessageScope) EnumValues() []string {
	return []string{
		string(MessageScopePrivate),
		string(MessageScopePublic),
		string(MessageScopeUndefined),
	}
}

// Validate validates the value of MessageScope.
func (v MessageScope) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MessageScope: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MessageScope.
func (v *MessageScope) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MessageScope(s)
	return nil
}

// Defines values for MessageStatus.
const (
	MessageStatusFailed    MessageStatus = "failed"
	MessageStatusReceived  MessageStatus = "received"
	MessageStatusSeen      MessageStatus = "seen"
	MessageStatusSending   MessageStatus = "sending"
	MessageStatusSent      MessageStatus = "sent"
	MessageStatusUndefined MessageStatus = "undefined"
)

// EnumValues returns all valid values for MessageStatus.
func (MessageStatus) EnumValues() []string {
	return []string{
		string(MessageStatusFailed),
		string(MessageStatusReceived),
		string(MessageStatusSeen),
		string(MessageStatusSending),
		string(MessageStatusSent),
		string(MessageStatusUndefined),
	}
}

// Validate validates the value of MessageStatus.
func (v MessageStatus) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MessageStatus: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MessageStatus.
func (v *MessageStatus) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MessageStatus(s)
	return nil
}

// Defines values for MessageType.
const (
	MessageTypeAudio   MessageType = "audio"
	MessageTypeCommand MessageType = "command"
	MessageTypeFile    MessageType = "file"
	MessageTypeImage   MessageType = "image"
	MessageTypeOrder   MessageType = "order"
	MessageTypeProduct MessageType = "product"
	MessageTypeSystem  MessageType = "system"
	MessageTypeText    MessageType = "text"
)

// EnumValues returns all valid values for MessageType.
func (MessageType) EnumValues() []string {
	return []string{
		string(MessageTypeAudio),
		string(MessageTypeCommand),
		string(MessageTypeFile),
		string(MessageTypeImage),
		string(MessageTypeOrder),
		string(MessageTypeProduct),
		string(MessageTypeSystem),
		string(MessageTypeText),
	}
}

// Validate validates the value of MessageType.
func (v MessageType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MessageType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MessageType.
func (v *MessageType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MessageType(s)
	return nil
}

// Defines values for ResponsibleType.
const (
	ResponsibleTypeBot  ResponsibleType = "bot"
	ResponsibleTypeUser ResponsibleType = "user"
)

// EnumValues returns all valid values for ResponsibleType.
func (ResponsibleType) EnumValues() []string {
	return []string{
		string(ResponsibleTypeBot),
		string(ResponsibleTypeUser),
	}
}

// Validate validates the value of ResponsibleType.
func (v ResponsibleType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for ResponsibleType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for ResponsibleType.
func (v *ResponsibleType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = ResponsibleType(s)
	return nil
}

// Defines values for Role.
const (
	RoleBotRoleDistributor Role = "distributor"
	RoleBotRoleHidden      Role = "hidden"
	RoleBotRoleResponsible Role = "responsible"
)

// EnumValues returns all valid values for Role.
func (Role) EnumValues() []string {
	return []string{
		string(RoleBotRoleDistributor),
		string(RoleBotRoleHidden),
		string(RoleBotRoleResponsible),
	}
}

// Validate validates the value of Role.
func (v Role) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for Role: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for Role.
func (v *Role) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = Role(s)
	return nil
}

// Defines values for SendingPolicyAfterReplyTimeout.
const (
	SendingPolicyAfterReplyTimeoutNo       SendingPolicyAfterReplyTimeout = "no"
	SendingPolicyAfterReplyTimeoutTemplate SendingPolicyAfterReplyTimeout = "template"
)

// EnumValues returns all valid values for SendingPolicyAfterReplyTimeout.
func (SendingPolicyAfterReplyTimeout) EnumValues() []string {
	return []string{
		string(SendingPolicyAfterReplyTimeoutNo),
		string(SendingPolicyAfterReplyTimeoutTemplate),
	}
}

// Validate validates the value of SendingPolicyAfterReplyTimeout.
func (v SendingPolicyAfterReplyTimeout) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for SendingPolicyAfterReplyTimeout: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for SendingPolicyAfterReplyTimeout.
func (v *SendingPolicyAfterReplyTimeout) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = SendingPolicyAfterReplyTimeout(s)
	return nil
}

// Defines values for SendingPolicyNewCustomer.
const (
	SendingPolicyNewCustomerNo       SendingPolicyNewCustomer = "no"
	SendingPolicyNewCustomerTemplate SendingPolicyNewCustomer = "template"
	SendingPolicyNewCustomerText     SendingPolicyNewCustomer = "text"
)

// EnumValues returns all valid values for SendingPolicyNewCustomer.
func (SendingPolicyNewCustomer) EnumValues() []string {
	return []string{
		string(SendingPolicyNewCustomerNo),
		string(SendingPolicyNewCustomerTemplate),
		string(SendingPolicyNewCustomerText),
	}
}

// Validate validates the value of SendingPolicyNewCustomer.
func (v SendingPolicyNewCustomer) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for SendingPolicyNewCustomer: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for SendingPolicyNewCustomer.
func (v *SendingPolicyNewCustomer) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = SendingPolicyNewCustomer(s)
	return nil
}

// Defines values for SendingPolicyOutgoing.
const (
	SendingPolicyOutgoingAllowed    SendingPolicyOutgoing = "allowed"
	SendingPolicyOutgoingRestricted SendingPolicyOutgoing = "restricted"
)

// EnumValues returns all valid values for SendingPolicyOutgoing.
func (SendingPolicyOutgoing) EnumValues() []string {
	return []string{
		string(SendingPolicyOutgoingAllowed),
		string(SendingPolicyOutgoingRestricted),
	}
}

// Validate validates the value of SendingPolicyOutgoing.
func (v SendingPolicyOutgoing) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for SendingPolicyOutgoing: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for SendingPolicyOutgoing.
func (v *SendingPolicyOutgoing) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = SendingPolicyOutgoing(s)
	return nil
}

// Defines values for SuggestionType.
const (
	SuggestionTypeEmail SuggestionType = "email"
	SuggestionTypePhone SuggestionType = "phone"
	SuggestionTypeText  SuggestionType = "text"
	SuggestionTypeUrl   SuggestionType = "url"
)

// EnumValues returns all valid values for SuggestionType.
func (SuggestionType) EnumValues() []string {
	return []string{
		string(SuggestionTypeEmail),
		string(SuggestionTypePhone),
		string(SuggestionTypeText),
		string(SuggestionTypeUrl),
	}
}

// Validate validates the value of SuggestionType.
func (v SuggestionType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for SuggestionType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for SuggestionType.
func (v *SuggestionType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = SuggestionType(s)
	return nil
}

// Defines values for SystemAction.
const (
	SystemActionCustomerBlocked   SystemAction = "customer_blocked"
	SystemActionCustomerUnblocked SystemAction = "customer_unblocked"
	SystemActionDialogAssign      SystemAction = "dialog_assign"
	SystemActionDialogClosed      SystemAction = "dialog_closed"
	SystemActionDialogOpened      SystemAction = "dialog_opened"
	SystemActionDialogUnassign    SystemAction = "dialog_unassign"
	SystemActionUserJoined        SystemAction = "user_joined"
	SystemActionUserLeft          SystemAction = "user_left"
)

// EnumValues returns all valid values for SystemAction.
func (SystemAction) EnumValues() []string {
	return []string{
		string(SystemActionCustomerBlocked),
		string(SystemActionCustomerUnblocked),
		string(SystemActionDialogAssign),
		string(SystemActionDialogClosed),
		string(SystemActionDialogOpened),
		string(SystemActionDialogUnassign),
		string(SystemActionUserJoined),
		string(SystemActionUserLeft),
	}
}

// Validate validates the value of SystemAction.
func (v SystemAction) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for SystemAction: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for SystemAction.
func (v *SystemAction) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = SystemAction(s)
	return nil
}

// Defines values for WAChannelQuality.
const (
	WAChannelQualityHigh   WAChannelQuality = "high"
	WAChannelQualityLow    WAChannelQuality = "low"
	WAChannelQualityMedium WAChannelQuality = "medium"
)

// EnumValues returns all valid values for WAChannelQuality.
func (WAChannelQuality) EnumValues() []string {
	return []string{
		string(WAChannelQualityHigh),
		string(WAChannelQualityLow),
		string(WAChannelQualityMedium),
	}
}

// Validate validates the value of WAChannelQuality.
func (v WAChannelQuality) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for WAChannelQuality: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for WAChannelQuality.
func (v *WAChannelQuality) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = WAChannelQuality(s)
	return nil
}

// Defines values for WAChannelStatus.
const (
	WAChannelStatusConnected  WAChannelStatus = "connected"
	WAChannelStatusFlagged    WAChannelStatus = "flagged"
	WAChannelStatusOffline    WAChannelStatus = "offline"
	WAChannelStatusPending    WAChannelStatus = "pending"
	WAChannelStatusRestricted WAChannelStatus = "restricted"
)

// EnumValues returns all valid values for WAChannelStatus.
func (WAChannelStatus) EnumValues() []string {
	return []string{
		string(WAChannelStatusConnected),
		string(WAChannelStatusFlagged),
		string(WAChannelStatusOffline),
		string(WAChannelStatusPending),
		string(WAChannelStatusRestricted),
	}
}

// Validate validates the value of WAChannelStatus.
func (v WAChannelStatus) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for WAChannelStatus: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for WAChannelStatus.
func (v *WAChannelStatus) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = WAChannelStatus(s)
	return nil
}

// Defines values for ListMembersParamsState.
const (
	ListMembersParamsStateActive ListMembersParamsState = "active"
	ListMembersParamsStateKicked ListMembersParamsState = "kicked"
	ListMembersParamsStateLeaved ListMembersParamsState = "leaved"
)

// EnumValues returns all valid values for ListMembersParamsState.
func (ListMembersParamsState) EnumValues() []string {
	return []string{
		string(ListMembersParamsStateActive),
		string(ListMembersParamsStateKicked),
		string(ListMembersParamsStateLeaved),
	}
}

// Validate validates the value of ListMembersParamsState.
func (v ListMembersParamsState) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for ListMembersParamsState: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for ListMembersParamsState.
func (v *ListMembersParamsState) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = ListMembersParamsState(s)
	return nil
}

// Defines values for ListMessagesParamsScope.
const (
	ListMessagesParamsScopePrivate ListMessagesParamsScope = "private"
	ListMessagesParamsScopePublic  ListMessagesParamsScope = "public"
)

// EnumValues returns all valid values for ListMessagesParamsScope.
func (ListMessagesParamsScope) EnumValues() []string {
	return []string{
		string(ListMessagesParamsScopePrivate),
		string(ListMessagesParamsScopePublic),
	}
}

// Validate validates the value of ListMessagesParamsScope.
func (v ListMessagesParamsScope) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for ListMessagesParamsScope: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for ListMessagesParamsScope.
func (v *ListMessagesParamsScope) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = ListMessagesParamsScope(s)
	return nil
}

// Actor Chat actor
type Actor struct {
	// Available User status indicator (for user of the user type only)
	Available bool `json:"available,omitempty"`

	// Avatar User avatar
	Avatar string `json:"avatar,omitempty"`

	// Email User email (for customer type user only)
	Email string `json:"email,omitempty"`

	// ExternalID External identifier of a user
	ExternalID string `json:"external_id"`

	// FirstName User name (for customer and user types only)
	FirstName string `json:"first_name,omitempty"`

	// ID User identifier
	ID int64 `json:"id"`

	// IsBlocked User blocking indicator (for customer type user only)
	IsBlocked bool `json:"is_blocked,omitempty"`

	// IsSystem System user indicator (for bot type user only)
	IsSystem bool `json:"is_system,omitempty"`

	// IsTechnicalAccount Technical account indicator (for user of the user type only)
	IsTechnicalAccount bool `json:"is_technical_account,omitempty"`

	// LastName User last name (for customer and user types only)
	LastName string `json:"last_name,omitempty"`

	// Name User nickname
	Name string `json:"name"`

	// Phone User phone number
	Phone string    `json:"phone,omitempty"`
	Type  ActorType `json:"type"`

	// Username User name (for customer type user only)
	Username string `json:"username,omitempty"`
}

// ActorType defines model for Actor.Type.
type ActorType string

// AudioMessageSetting Support settings for audio messages in the channel
type AudioMessageSetting struct {
	// Creating Support for operation with messages of the given type
	Creating ChannelFeature `json:"creating,omitempty"`

	// Deleting Support for operation with messages of the given type
	Deleting ChannelFeature `json:"deleting,omitempty"`

	// MaxItemSize Maximum size allowed for a single audio file in bytes
	MaxItemSize *int64 `json:"max_item_size,omitempty"`

	// MaxItemsCount Maximum number of audio attachments allowed per message
	MaxItemsCount *int `json:"max_items_count,omitempty"`

	// Quoting Support for operation with messages of the given type
	Quoting ChannelFeature `json:"quoting,omitempty"`

	// Reaction Support for operation with messages of the given type
	Reaction ChannelFeature `json:"reaction,omitempty"`
}

// Boolean Boolean type
type Boolean string

// Bot Bot information
type Bot struct {
	// AvatarUrl Public URL of the bot's avatar image
	AvatarUrl *string `json:"avatar_url,omitempty"`

	// ClientId Unique external client identifier of the bot
	ClientId string `json:"client_id"`

	// CreatedAt Date and time in RFC 3339 format with microseconds
	CreatedAt DateTimeRFC3339Micro `json:"created_at"`

	// DeactivatedAt Date and time in RFC 3339 format with microseconds
	DeactivatedAt *DateTimeRFC3339Micro `json:"deactivated_at"`

	// ID Internal unique identifier of the bot
	ID int64 `json:"id"`

	// IsActive Indicates whether the bot is currently active
	IsActive bool `json:"is_active"`

	// IsSelf Indicates whether this bot is the one currently authenticated
	IsSelf bool `json:"is_self"`

	// IsSystem Indicates whether this bot is a system-level bot
	IsSystem bool `json:"is_system"`

	// Name Human-readable name of the bot
	Name string `json:"name"`

	// Roles List of roles assigned to the bot
	Roles []Role `json:"roles"`

	// UpdatedAt Date and time in RFC 3339 format with microseconds
	UpdatedAt *DateTimeRFC3339Micro `json:"updated_at"`
}

// Channel Represents a communication channel used by a bot
type Channel struct {
	// Avatar URI of the channel's custom avatar image
	Avatar string `json:"avatar"`

	// ID Unique identifier of the channel
	ID int64 `json:"id"`

	// IsActive Indicates whether the channel is currently active
	IsActive bool `json:"is_active"`

	// Name Optional human-readable name of the channel
	Name *string `json:"name,omitempty"`

	// Settings Configuration settings specific to the channel type
	Settings ChannelSettings `json:"settings"`

	// TransportID Identifier of the underlying transport system used by the channel
	TransportID int64 `json:"transport_id"`

	// Type Type of the communication channel
	Type ChannelType `json:"type"`
}

// ChannelFeature Support for operation with messages of the given type
type ChannelFeature string

// ChannelListResponseItem Communication channel used by a bot
type ChannelListResponseItem struct {
	// ActivatedAt Date and time in RFC 3339 format with microseconds
	ActivatedAt DateTimeRFC3339Micro `json:"activated_at"`

	// CreatedAt Date and time in RFC 3339 format with microseconds
	CreatedAt DateTimeRFC3339Micro `json:"created_at"`

	// DeactivatedAt Date and time in RFC 3339 format with microseconds
	DeactivatedAt *DateTimeRFC3339Micro `json:"deactivated_at"`

	// ID Unique identifier of the channel
	ID int64 `json:"id"`

	// IsActive Indicates whether the channel is currently active
	IsActive bool `json:"is_active"`

	// Name Optional human-readable name of the channel
	Name *string `json:"name"`

	// Settings Configuration settings specific to the channel type
	Settings ChannelSettings `json:"settings"`

	// Type Type of the communication channel
	Type ChannelType `json:"type"`

	// UpdatedAt Date and time in RFC 3339 format with microseconds
	UpdatedAt *DateTimeRFC3339Micro `json:"updated_at"`
}

// ChannelSettings Configuration options and capabilities for a specific communication channel
type ChannelSettings struct {
	// Audio Support settings for audio messages in the channel
	Audio AudioMessageSetting `json:"audio,omitempty"`

	// CustomerExternalId Support for external customer identifiers
	CustomerExternalId CustomerExternalId `json:"customer_external_id,omitempty"`

	// File File messages support
	File FileMessageSetting `json:"file,omitempty"`

	// Image Media messages support
	Image ImageMessageSetting `json:"image,omitempty"`

	// Order Order messages support
	Order OrderMessageSetting `json:"order,omitempty"`

	// Product Product messages support
	Product ProductMessageSetting `json:"product,omitempty"`

	// Reactions Support for working with reactions for messages
	Reactions Reactions `json:"reactions,omitempty"`

	// SendingPolicy Message sending policy
	SendingPolicy SendingPolicy `json:"sending_policy,omitempty"`

	// Status Transmitting message status information
	Status StatusSetting `json:"status,omitempty"`

	// Suggestions Support for quick response types
	Suggestions Suggestions `json:"suggestions,omitempty"`

	// Template Support for message templates
	Template TemplateSetting `json:"template,omitempty"`

	// Text Text messages support
	Text TextMessageSetting `json:"text,omitempty"`

	// Whatsapp WhatsApp channel properties
	Whatsapp *WAChannelProperties `json:"whatsapp,omitempty"`
}

// ChannelType Type of channel used for communication
type ChannelType string

// Chat Represents a communication thread between users and/or a customer within a specific channel
type Chat struct {
	// AuthorID ID of the user who initiated the chat
	AuthorID *int64 `json:"author_id,omitempty"`

	// Avatar URL of the chat's avatar image
	Avatar *string `json:"avatar,omitempty"`

	// Channel The communication channel (e.g., Telegram, Viber) associated with this chat
	Channel *Channel `json:"channel,omitempty"`

	// Customer The customer participating in the chat, if any
	Customer *Actor `json:"customer"`

	// ID Unique identifier of the chat
	ID int64 `json:"id"`

	// LastActivity Date and time in RFC 3339 format
	LastActivity *DateTimeRFC3339 `json:"last_activity,omitempty"`

	// LastDialog The most recent dialog in the chat
	LastDialog *Dialog `json:"last_dialog,omitempty"`

	// LastMessage The latest message in the chat, including system or service messages
	LastMessage *Message `json:"last_message,omitempty"`

	// LastUserMessage The most recent message sent by a user in the chat
	LastUserMessage *LastUserMessage `json:"last_user_message,omitempty"`

	// Members List of chat participants
	Members *Members `json:"members,omitempty"`

	// Name Display name of the chat
	Name *string `json:"name,omitempty"`

	// NotReadMessagesCount Number of unread messages in the chat
	NotReadMessagesCount int64 `json:"not_read_messages,omitempty"`

	// ReplyDeadline Date and time in RFC 3339 format
	ReplyDeadline *DateTimeRFC3339 `json:"reply_deadline,omitempty"`

	// Unread Indicates whether any user has unread messages in this chat
	Unread bool `json:"unread,omitempty"`

	// WaitingLevel Current urgency level of the chat based on business logic (e.g., SLA violations).
	WaitingLevel *ChatWaitingLevel `json:"waiting_level,omitempty"`

	// WaitingLevelTransitionTime Date and time in RFC 3339 format
	WaitingLevelTransitionTime *DateTimeRFC3339 `json:"waiting_level_transition_time,omitempty"`
}

// ChatWaitingLevel Current urgency level of the chat based on business logic (e.g., SLA violations).
type ChatWaitingLevel string

// ChatMemberListResponseItem Chat member object containing user ID, chat ID, membership state and timestamps
type ChatMemberListResponseItem struct {
	// ChatID ID of the chat the user is a member of
	ChatID int64 `json:"chat_id"`

	// CreatedAt Date and time in RFC 3339 format with microseconds
	CreatedAt DateTimeRFC3339Micro `json:"created_at"`

	// ID Unique ID of the chat membership record
	ID int64 `json:"id"`

	// IsAuthor Indicates whether the user is the author of the chat
	IsAuthor bool `json:"is_author"`

	// State Membership state of the user in the chat
	State ChatMemberListResponseItemState `json:"state"`

	// UpdatedAt Date and time in RFC 3339 format with microseconds
	UpdatedAt *DateTimeRFC3339Micro `json:"updated_at,omitempty"`

	// UserID ID of the user in the system
	UserID int64 `json:"user_id"`
}

// ChatMemberListResponseItemState Membership state of the user in the chat
type ChatMemberListResponseItemState string

// ChatTimestamps Represents dates and times of creation and last update of the chat
type ChatTimestamps struct {
	// CreatedAt Date and time in RFC 3339 format with microseconds
	CreatedAt DateTimeRFC3339Micro `json:"created_at"`

	// UpdatedAt Date and time in RFC 3339 format with microseconds
	UpdatedAt *DateTimeRFC3339Micro `json:"updated_at"`
}

// ChatsListResponseItem defines model for ChatsListResponseItem.
type ChatsListResponseItem struct {
	// AuthorID ID of the user who initiated the chat
	AuthorID *int64 `json:"author_id,omitempty"`

	// Avatar URL of the chat's avatar image
	Avatar *string `json:"avatar,omitempty"`

	// Channel The communication channel (e.g., Telegram, Viber) associated with this chat
	Channel *Channel `json:"channel,omitempty"`

	// CreatedAt Date and time in RFC 3339 format with microseconds
	CreatedAt DateTimeRFC3339Micro `json:"created_at"`

	// Customer The customer participating in the chat, if any
	Customer *Actor `json:"customer"`

	// ID Unique identifier of the chat
	ID int64 `json:"id"`

	// LastActivity Date and time in RFC 3339 format
	LastActivity *DateTimeRFC3339 `json:"last_activity,omitempty"`

	// LastDialog The most recent dialog in the chat
	LastDialog *Dialog `json:"last_dialog,omitempty"`

	// LastMessage The latest message in the chat, including system or service messages
	LastMessage *Message `json:"last_message,omitempty"`

	// LastUserMessage The most recent message sent by a user in the chat
	LastUserMessage *LastUserMessage `json:"last_user_message,omitempty"`

	// Members List of chat participants
	Members *Members `json:"members,omitempty"`

	// Name Display name of the chat
	Name *string `json:"name,omitempty"`

	// NotReadMessagesCount Number of unread messages in the chat
	NotReadMessagesCount int64 `json:"not_read_messages,omitempty"`

	// ReplyDeadline Date and time in RFC 3339 format
	ReplyDeadline *DateTimeRFC3339 `json:"reply_deadline,omitempty"`

	// Unread Indicates whether any user has unread messages in this chat
	Unread bool `json:"unread,omitempty"`

	// UpdatedAt Date and time in RFC 3339 format with microseconds
	UpdatedAt *DateTimeRFC3339Micro `json:"updated_at"`

	// WaitingLevel Current urgency level of the chat based on business logic (e.g., SLA violations).
	WaitingLevel *ChatsListResponseItemWaitingLevel `json:"waiting_level,omitempty"`

	// WaitingLevelTransitionTime Date and time in RFC 3339 format
	WaitingLevelTransitionTime *DateTimeRFC3339 `json:"waiting_level_transition_time,omitempty"`
}

// ChatsListResponseItemWaitingLevel Current urgency level of the chat based on business logic (e.g., SLA violations).
type ChatsListResponseItemWaitingLevel string

// ColorCode Code of tag color
type ColorCode string

// Command Represents a single bot command with metadata.
type Command struct {
	// CreatedAt Date and time in RFC 3339 format with microseconds
	CreatedAt DateTimeRFC3339Micro `json:"created_at"`

	// Description Human-readable description of the command.
	Description string `json:"description"`

	// ID Unique identifier of the command.
	ID int64 `json:"id"`

	// Name Unique command name, used for execution or identification
	Name string `json:"name"`

	// UpdatedAt Date and time in RFC 3339 format with microseconds
	UpdatedAt *DateTimeRFC3339Micro `json:"updated_at"`
}

// CommandCreate defines model for CommandCreate.
type CommandCreate struct {
	// CreatedAt Date and time in RFC 3339 format
	CreatedAt DateTimeRFC3339 `json:"created_at"`

	// Description Human-readable description of the command.
	Description string `json:"description"`

	// ID Unique identifier of the command.
	ID int64 `json:"id"`

	// Name Unique command name, used for execution or identification
	Name string `json:"name"`

	// UpdatedAt Date and time in RFC 3339 format
	UpdatedAt *DateTimeRFC3339 `json:"updated_at,omitempty"`
}

// Cost Represents a monetary value with its corresponding currency
type Cost struct {
	// Currency Currency code
	Currency string `binding:"required,currency" json:"currency"`

	// Value Numerical value of the cost
	Value float64 `binding:"gte=0" json:"value"`
}

// CreateCommandRequestBody Represents a request body for creating a new command
type CreateCommandRequestBody struct {
	// Description Human-readable description of the command's purpose or behavior
	Description string `binding:"required,min=0,max=64" json:"description"`

	// Name Unique identifier for the command
	Name string `json:"name,omitempty"`
}

// Customer Dialog object
type Customer struct {
	Avatar    *string `json:"avatar,omitempty"`
	ChannelId *int64  `json:"channel_id,omitempty"`
	Country   *string `json:"country,omitempty"`

	// CreatedAt Date and time in RFC 3339 format with microseconds
	CreatedAt  DateTimeRFC3339Micro `json:"created_at"`
	Email      *string              `json:"email,omitempty"`
	ExternalID *string              `json:"external_id,omitempty"`
	FirstName  *string              `json:"first_name,omitempty"`
	ID         int64                `json:"id"`
	IsBlocked  bool                 `json:"is_blocked"`
	Language   *string              `json:"language,omitempty"`
	LastName   *string              `json:"last_name,omitempty"`
	Phone      *string              `json:"phone,omitempty"`
	ProfileURL *string              `json:"profile_url,omitempty"`

	// RevokedAt Date and time in RFC 3339 format with microseconds
	RevokedAt *DateTimeRFC3339Micro `json:"revoked_at"`

	// UpdatedAt Date and time in RFC 3339 format with microseconds
	UpdatedAt *DateTimeRFC3339Micro `json:"updated_at"`
	Username  *string               `json:"username,omitempty"`
	Utm       *Utm                  `json:"utm"`
}

// CustomerExternalId Support for external customer identifiers
type CustomerExternalId string

// Dialog Dialog object
type Dialog struct {
	AssignedAt *DateTimeRFC3339 `json:"assigned_at"`

	// ClosedAt Date and time in RFC 3339 format
	ClosedAt *DateTimeRFC3339 `json:"closed_at"`

	// CreatedAt Date and time in RFC 3339 format
	CreatedAt   DateTimeRFC3339 `json:"created_at"`
	ID          int64           `json:"id"`
	Responsible *Actor          `json:"responsible"`
	Utm         *Utm            `json:"utm"`
}

// DialogListResponseItem Dialog item in the list response
type DialogListResponseItem struct {
	// BeginMessageID ID of the first message in the dialog
	BeginMessageID *int64 `json:"begin_message_id"`

	// BotID ID of the bot assigned to the dialog, if any
	BotID *int64 `json:"bot_id"`

	// ChatID ID of the chat this dialog belongs to
	ChatID int64 `json:"chat_id"`

	// ClosedAt Date and time in RFC 3339 format with microseconds
	ClosedAt *DateTimeRFC3339Micro `json:"closed_at"`

	// CreatedAt Date and time in RFC 3339 format with microseconds
	CreatedAt DateTimeRFC3339Micro `json:"created_at"`

	// EndingMessageID ID of the last message in the dialog
	EndingMessageID *int64 `json:"ending_message_id"`

	// ID Unique identifier of the dialog
	ID int64 `json:"id"`

	// IsActive Indicates if the dialog is currently active
	IsActive bool `json:"is_active"`

	// IsAssigned Indicates if the dialog is assigned to someone
	IsAssigned bool `json:"is_assigned"`

	// Responsible Current responsible entity for the dialog
	Responsible *Responsible `json:"responsible,omitempty"`

	// Tags List of tags associated with the dialog
	Tags []Tag `json:"tags,omitempty"`

	// UpdatedAt Date and time in RFC 3339 format with microseconds
	UpdatedAt *DateTimeRFC3339Micro `json:"updated_at"`

	// Utm UTM parameters associated with the dialog
	Utm *Utm `json:"utm,omitempty"`
}

// File Metadata and processing status of an uploaded file
type File struct {
	// ID Unique identifier of the file
	ID openapi_types.UUID `json:"id"`

	// Size Size of the file in bytes
	Size int `json:"size"`

	// Transcription Optional text transcription of the file content, if applicable
	Transcription *string `json:"transcription"`

	// TranscriptionStatus Status of the file transcription process
	TranscriptionStatus FileTranscriptionStatus `json:"transcription_status,omitempty"`

	// Type File type
	Type FileType `json:"type"`
}

// FileMessageSetting File messages support
type FileMessageSetting struct {
	// Creating Support for operation with messages of the given type
	Creating ChannelFeature `json:"creating,omitempty"`

	// Deleting Support for operation with messages of the given type
	Deleting ChannelFeature `json:"deleting,omitempty"`

	// Editing Support for operation with messages of the given type
	Editing ChannelFeature `json:"editing,omitempty"`

	// MaxItemSize Maximum file size to send
	MaxItemSize *int64 `json:"max_item_size,omitempty"`

	// MaxItemsCount Maximum number of file attachments per message
	MaxItemsCount *int `json:"max_items_count,omitempty"`

	// NoteMaxCharsCount Maximum number of characters in a file message annotation
	NoteMaxCharsCount *uint16 `json:"note_max_chars_count,omitempty"`

	// Quoting Support for operation with messages of the given type
	Quoting ChannelFeature `json:"quoting,omitempty"`

	// Reaction Support for operation with messages of the given type
	Reaction ChannelFeature `json:"reaction,omitempty"`
}

// FileTranscriptionStatus Current status of the file transcription process
type FileTranscriptionStatus string

// FileType File type
type FileType string

// FileWithUrl defines model for FileWithUrl.
type FileWithUrl struct {
	// ID Unique identifier of the file
	ID openapi_types.UUID `json:"id"`

	// Size Size of the file in bytes
	Size int `json:"size"`

	// Transcription Optional text transcription of the file content, if applicable
	Transcription *string `json:"transcription"`

	// TranscriptionStatus Status of the file transcription process
	TranscriptionStatus FileTranscriptionStatus `json:"transcription_status,omitempty"`

	// Type File type
	Type FileType `json:"type"`

	// Url Direct URL for downloading or accessing the uploaded file
	Url string `binding:"omitempty,Url" json:"url"`
}

// Histogram Sound diagram (for audio type messages only)
type Histogram = []int

// ImageMessageSetting Media messages support
type ImageMessageSetting struct {
	// Creating Support for operation with messages of the given type
	Creating ChannelFeature `json:"creating,omitempty"`

	// Deleting Support for operation with messages of the given type
	Deleting ChannelFeature `json:"deleting,omitempty"`

	// Editing Support for operation with messages of the given type
	Editing ChannelFeature `json:"editing,omitempty"`

	// MaxItemSize Maximum image size to send
	MaxItemSize *int64 `json:"max_item_size,omitempty"`

	// MaxItemsCount Maximum number of media attachments per message
	MaxItemsCount *int `json:"max_items_count,omitempty"`

	// NoteMaxCharsCount Maximum number of characters in a media message annotation
	NoteMaxCharsCount *uint16 `json:"note_max_chars_count,omitempty"`

	// Quoting Support for operation with messages of the given type
	Quoting ChannelFeature `json:"quoting,omitempty"`

	// Reaction Support for operation with messages of the given type
	Reaction ChannelFeature `json:"reaction,omitempty"`
}

// LastUserMessage The most recent message sent by a user in the chat
type LastUserMessage struct {
	// ID Unique identifier of the last user message
	ID int64 `json:"id"`
}

// Member A participant in the chat, representing a user and their current membership status
type Member struct {
	// IsAuthor Indicates whether the member is the author (creator) of the chat
	IsAuthor bool `json:"is_author"`

	// State The current state of the member in the chat
	State MemberState `json:"state"`

	// User Information about the user who is a member of the chat
	User Actor `json:"user"`
}

// MemberState The current state of the member in the chat
type MemberState string

// Members List of participants involved in the chat
type Members = []Member

// Message Message object representing a single chat message
type Message struct {
	// Action System-level action represented by the message
	Action *SystemAction `json:"action"`

	// Actions List of interactive actions associated with the message
	Actions []MessageAction `json:"actions"`

	// ChatID ID of the chat this message belongs to
	ChatID int64 `json:"chat_id"`

	// Content Text content of the message
	Content *string `json:"content"`

	// Dialog Optional dialog related to the message
	Dialog *MessageDialog `json:"dialog"`

	// Error Error info related to message sending or processing
	Error *MessageError `json:"error"`

	// From Actor who sent the message
	From *Actor `json:"from,omitempty"`

	// ID Unique identifier of the message
	ID int64 `json:"id"`

	// IsEdit Indicates whether the message was edited
	IsEdit bool `json:"is_edit"`

	// IsRead Indicates whether the message was read
	IsRead bool `json:"is_read"`

	// Items List of attached files
	Items []MessageFile `json:"items,omitempty"`

	// Note Optional internal note or comment for the message
	Note string `json:"note"`

	// Order Optional order data linked to the message
	Order *MessageOrder `json:"order"`

	// Product Optional product data referenced in the message
	Product *MessageProduct `json:"product"`

	// Quote Quoted message, if this is a reply
	Quote *QuoteMessage `json:"quote"`

	// Responsible User responsible for this message or task
	Responsible *Actor `json:"responsible"`

	// Scope Scope of the message
	Scope MessageScope `json:"scope"`

	// Status Current status of the message
	Status MessageStatus `json:"status"`

	// Time Timestamp when the message was created
	Time DateTimeRFC3339 `json:"time"`

	// TransportAttachments Attachments specific to a transport layer
	TransportAttachments *MessageTransportAttachments `json:"transport_attachments"`

	// Type Type of the message
	Type MessageType `json:"type"`

	// User User associated with the message
	User *Actor `json:"user"`
}

// MessageAction Defines possible actions that can be performed on a message
type MessageAction string

// MessageDialog Message dialog
type MessageDialog struct {
	// ID Dialog identifier
	ID int64 `json:"id"`
}

// MessageError Message error details (only for messages with status `failed`)
type MessageError struct {
	Code MessageErrorCode `binding:"enum-valid" json:"code"`

	// Message Text description of error
	Message string `json:"message,omitempty"`
}

// MessageErrorCode Message error code
type MessageErrorCode string

// MessageFile Attached message file
type MessageFile struct {
	// Caption Text description of the media attachment
	Caption string `json:"caption,omitempty"`

	// Duration Audio recording duration (for audio type messages only)
	Duration int `json:"duration,omitempty"`

	// Height Image height in pixels (for image type messages only)
	Height    int       `json:"height,omitempty"`
	Histogram Histogram `json:"histogram,omitempty"`

	// ID UUID of the attached file
	ID   openapi_types.UUID `json:"id,omitempty"`
	Kind FileType           `json:"kind,omitempty"`

	// PreviewURL URL of the file to upload
	PreviewURL string `json:"preview_url,omitempty"`

	// Size Attachment size (in bytes)
	Size int `json:"size,omitempty"`

	// Transcription Transcription of the uploaded file
	Transcription string `json:"transcription,omitempty"`

	// Type Attachment type
	Type string `json:"type,omitempty"`

	// Width Image width in pixels (for image type messages only)
	Width int `json:"width,omitempty"`
}

// MessageListResponseItem defines model for MessageListResponseItem.
type MessageListResponseItem struct {
	// Action System-level action represented by the message
	Action *SystemAction `json:"action"`

	// Actions List of interactive actions associated with the message
	Actions []MessageAction `json:"actions"`

	// ChannelID ID of the channel where the message was sent
	ChannelID *int64 `json:"channel_id,omitempty"`

	// ChannelSentAt Date and time in RFC 3339 format with microseconds
	ChannelSentAt *DateTimeRFC3339Micro `json:"channel_sent_at"`

	// ChatID ID of the chat this message belongs to
	ChatID int64 `json:"chat_id"`

	// Content Text content of the message
	Content *string `json:"content"`

	// CreatedAt Date and time in RFC 3339 format with microseconds
	CreatedAt DateTimeRFC3339Micro `json:"created_at"`

	// Dialog Optional dialog related to the message
	Dialog *MessageDialog `json:"dialog"`

	// Error Error info related to message sending or processing
	Error *MessageError `json:"error"`

	// From Actor who sent the message
	From *Actor `json:"from,omitempty"`

	// ID Unique identifier of the message
	ID int64 `json:"id"`

	// IsEdit Indicates whether the message was edited
	IsEdit bool `json:"is_edit"`

	// IsRead Indicates whether the message was read
	IsRead bool `json:"is_read"`

	// Items List of attached files
	Items []MessageFile `json:"items,omitempty"`

	// Note Optional internal note or comment for the message
	Note string `json:"note"`

	// Order Optional order data linked to the message
	Order *MessageOrder `json:"order"`

	// Product Optional product data referenced in the message
	Product *MessageProduct `json:"product"`

	// Quote Quoted message, if this is a reply
	Quote *QuoteMessage `json:"quote"`

	// Responsible User responsible for this message or task
	Responsible *Actor `json:"responsible"`

	// Scope Scope of the message
	Scope MessageScope `json:"scope"`

	// Status Current status of the message
	Status MessageStatus `json:"status"`

	// Time Timestamp when the message was created
	Time DateTimeRFC3339 `json:"time"`

	// TransportAttachments Attachments specific to a transport layer
	TransportAttachments *MessageTransportAttachments `json:"transport_attachments"`

	// Type Type of the message
	Type MessageType `json:"type"`

	// UpdatedAt Date and time in RFC 3339 format with microseconds
	UpdatedAt *DateTimeRFC3339Micro `json:"updated_at"`

	// User User associated with the message
	User *Actor `json:"user"`
}

// MessageOrder Represents the details of an order within a message
type MessageOrder struct {
	// Cost Represents a monetary value with its corresponding currency
	Cost *Cost `json:"cost,omitempty"`

	// Date Order creation date
	Date *time.Time `json:"date,omitempty"`

	// Delivery Order delivery information
	Delivery *MessageOrderDelivery `json:"delivery,omitempty"`

	// Discount Represents a monetary value with its corresponding currency
	Discount *Cost `json:"discount,omitempty"`

	// ExternalID External identifier of an order
	ExternalID int64 `json:"external_id,omitempty"`

	// Items Array of order items
	Items []MessageOrderItem `json:"items,omitempty"`

	// Number Order number
	Number string `binding:"max=255" json:"number,omitempty"`

	// Payments Payments array
	Payments []MessageOrderPayment `json:"payments,omitempty"`
	Status   *MessageOrderStatus   `json:"status,omitempty"`

	// Url Order URL
	Url string `binding:"max=2048" json:"url,omitempty"`
}

// MessageOrderDelivery Order delivery information
type MessageOrderDelivery struct {
	// Address Delivery address
	Address string `json:"address,omitempty"`

	// Comment Delivery comment
	Comment string `json:"comment,omitempty"`

	// Name Delivery method name
	Name string `json:"name,omitempty"`

	// Price Represents a monetary value with its corresponding currency
	Price *Cost `json:"price,omitempty"`
}

// MessageOrderItem Order product
type MessageOrderItem struct {
	// ExternalID External identifier of a product
	ExternalID int64 `json:"external_id,omitempty"`

	// Img Product image
	Img string `binding:"max=2048" json:"img,omitempty"`

	// Name Product name
	Name string `binding:"max=255" json:"name,omitempty"`

	// Price Represents a monetary value with its corresponding currency
	Price    *Cost    `json:"price,omitempty"`
	Quantity Quantity `json:"quantity,omitempty"`

	// Url Product URL
	Url string `binding:"max=2048" json:"url,omitempty"`
}

// MessageOrderPayment Order payment information
type MessageOrderPayment struct {
	// Amount Represents a monetary value with its corresponding currency
	Amount *Cost `json:"amount,omitempty"`

	// Name Payment name
	Name string `json:"name,omitempty"`

	// Status Order payment status
	Status *MessageOrderPaymentStatus `json:"status,omitempty"`
}

// MessageOrderPaymentStatus Order payment status
type MessageOrderPaymentStatus struct {
	// Name Payment name
	Name string `json:"name,omitempty"`

	// Payed Payment execution indicator
	Payed *bool `json:"payed,omitempty"`
}

// MessageOrderStatus Order status
type MessageOrderStatus struct {
	Code MessageOrderStatusCode `binding:"enum-valid" json:"code,omitempty"`

	// Name Status name
	Name string `binding:"max=255" json:"name,omitempty"`
}

// MessageOrderStatusCode Status code
type MessageOrderStatusCode string

// MessageProduct Describes a product mentioned in a message
type MessageProduct struct {
	// Article Product description
	Article string `binding:"max=128" json:"article,omitempty"`

	// Cost Represents a monetary value with its corresponding currency
	Cost *Cost `json:"cost,omitempty"`

	// ID Product identifier
	ID uint64 `json:"id"`

	// Img Product image URL
	Img string `binding:"max=2048" json:"img,omitempty"`

	// Name Product name
	Name string `binding:"required,min=1,max=255" json:"name"`

	// Unit Units of measure of the product
	Unit string `binding:"max=16" json:"unit"`

	// Url Product URL
	Url string `binding:"max=2048" json:"url,omitempty"`
}

// MessageScope Message scope
type MessageScope string

// MessageStatus Message status
type MessageStatus string

// MessageTransportAttachments Transport attachments
type MessageTransportAttachments struct {
	// Suggestions Quick responses
	Suggestions []Suggestion `json:"suggestions,omitempty"`
}

// MessageType Type of message
type MessageType string

// OrderMessageSetting Order messages support
type OrderMessageSetting struct {
	// Creating Support for operation with messages of the given type
	Creating ChannelFeature `json:"creating,omitempty"`

	// Deleting Support for operation with messages of the given type
	Deleting ChannelFeature `json:"deleting,omitempty"`

	// Editing Support for operation with messages of the given type
	Editing ChannelFeature `json:"editing,omitempty"`

	// Quoting Support for operation with messages of the given type
	Quoting ChannelFeature `json:"quoting,omitempty"`

	// Reaction Support for operation with messages of the given type
	Reaction ChannelFeature `json:"reaction,omitempty"`
}

// ProductMessageSetting Product messages support
type ProductMessageSetting struct {
	// Creating Support for operation with messages of the given type
	Creating ChannelFeature `json:"creating,omitempty"`

	// Deleting Support for operation with messages of the given type
	Deleting ChannelFeature `json:"deleting,omitempty"`

	// Editing Support for operation with messages of the given type
	Editing ChannelFeature `json:"editing,omitempty"`

	// Quoting Support for operation with messages of the given type
	Quoting ChannelFeature `json:"quoting,omitempty"`

	// Reaction Support for operation with messages of the given type
	Reaction ChannelFeature `json:"reaction,omitempty"`
}

// Quantity Quantity
type Quantity struct {
	// Unit Units of measure
	Unit string `binding:"max=16" json:"unit,omitempty"`

	// Value Quantitative value
	Value float64 `binding:"gte=0" json:"value,omitempty"`
}

// QuoteMessage Quoted message
type QuoteMessage struct {
	// Content Message text
	Content string `json:"content,omitempty"`

	// From Chat actor
	From *Actor `json:"from,omitempty"`

	// ID Identifier of the quoted message
	ID int64 `json:"id"`

	// Items Media attachments of the quoted message
	Items []MessageFile `json:"items,omitempty"`

	// Time Message sending time
	Time DateTimeRFC3339 `json:"time"`
	Type MessageType     `binding:"enum-valid" json:"type"`
}

// Reactions Support for working with reactions for messages
type Reactions struct {
	// Dictionary Dictionary of available reactions
	Dictionary []string `json:"dictionary,omitempty"`

	// MaxCount Maximum number of reactions added from the system
	MaxCount int64 `json:"max_count,omitempty"`
}

// Responsible Entity responsible for the dialog (user or bot)
type Responsible struct {
	// AssignedAt Date and time in RFC 3339 format with microseconds
	AssignedAt *DateTimeRFC3339Micro `json:"assigned_at"`

	// ExternalID External identifier for the responsible entity
	ExternalID *string `json:"external_id,omitempty"`

	// ID Unique identifier of the responsible entity
	ID int64 `json:"id"`

	// Type Type of the responsible entity
	Type ResponsibleType `json:"type"`
}

// ResponsibleType Type of the responsible entity
type ResponsibleType string

// Role Bot role type
type Role string

// Roles Bot role types array
type Roles = []Role

// SendMessageRequestBody Represents the payload of a message, including content, attachments, and related metadata depending on the message type
type SendMessageRequestBody struct {
	// ChatID ID of the chat where the message is being sent
	ChatID int64 `binding:"required" json:"chat_id"`

	// Content Message text content (required for text messages only)
	Content *string `json:"content,omitempty"`

	// Items File attachments (required for file, audio and image messages)
	Items *[]struct {
		// Caption Caption for the file
		Caption *string `binding:"min=1,max=1024" json:"caption,omitempty"`

		// ID Unique identifier of the file
		ID openapi_types.UUID `json:"id"`
	} `json:"items,omitempty"`

	// Note Note or description for the file (required for file, audio and image messages)
	Note *string `json:"note,omitempty"`

	// Order Order data (required for order messages only)
	Order *MessageOrder `json:"order,omitempty"`

	// Product Product data (required for product messages only)
	Product *MessageProduct `json:"product,omitempty"`

	// QuoteMessageId ID of the quoted message (required for text messages only)
	QuoteMessageId int64 `json:"quote_message_id,omitempty"`

	// Scope Scope of the message (e.g., user, system)
	Scope                MessageScope                 `binding:"required" json:"scope"`
	TransportAttachments *MessageTransportAttachments `json:"transport_attachments"`

	// Type Type of the message (e.g. text, file, order, product)
	Type *MessageType `json:"type,omitempty"`
}

// SendingPolicy Message sending policy
type SendingPolicy struct {
	// AfterReplyTimeout Types of messages to send after response time expires
	AfterReplyTimeout SendingPolicyAfterReplyTimeout `json:"after_reply_timeout,omitempty"`

	// NewCustomer Types of messages to send to a new customer
	NewCustomer SendingPolicyNewCustomer `json:"new_customer,omitempty"`

	// Outgoing Outgoing message support
	Outgoing SendingPolicyOutgoing `json:"outgoing,omitempty"`
}

// SendingPolicyAfterReplyTimeout Types of messages to send after response time expires
type SendingPolicyAfterReplyTimeout string

// SendingPolicyNewCustomer Types of messages to send to a new customer
type SendingPolicyNewCustomer string

// SendingPolicyOutgoing Outgoing message support
type SendingPolicyOutgoing string

// StatusSetting Transmitting message status information
type StatusSetting struct {
	// Delivered Support for operation with messages of the given type
	Delivered ChannelFeature `json:"delivered,omitempty"`

	// Read Support for operation with messages of the given type
	Read ChannelFeature `json:"read,omitempty"`
}

// Suggestion Quick response suggestion
type Suggestion struct {
	// Payload Quick response payload
	Payload string `json:"payload,omitempty"`

	// Title Quick response name
	Title string         `json:"title,omitempty"`
	Type  SuggestionType `binding:"enum-valid" json:"type,omitempty"`
}

// SuggestionType Quick response type
type SuggestionType string

// Suggestions Support for quick response types
type Suggestions struct {
	// Email Support for operation with messages of the given type
	Email ChannelFeature `json:"email,omitempty"`

	// Phone Support for operation with messages of the given type
	Phone ChannelFeature `json:"phone,omitempty"`

	// Text Support for operation with messages of the given type
	Text ChannelFeature `json:"text,omitempty"`

	// Url Support for operation with messages of the given type
	Url ChannelFeature `json:"url,omitempty"`
}

// SystemAction System action of the message (for system type messages only)
type SystemAction string

// Tag Tag assigned to a dialog or entity
type Tag struct {
	// ColorCode Color code associated with the tag
	ColorCode ColorCode `json:"color_code"`

	// Name Name of the tag
	Name string `json:"name"`
}

// TemplateSetting Support for message templates
type TemplateSetting struct {
	// Creation Support for creating templates in the system
	Creation bool `json:"creation,omitempty"`
}

// TextMessageSetting Text messages support
type TextMessageSetting struct {
	// Creating Support for operation with messages of the given type
	Creating ChannelFeature `json:"creating,omitempty"`

	// Deleting Support for operation with messages of the given type
	Deleting ChannelFeature `json:"deleting,omitempty"`

	// Editing Support for operation with messages of the given type
	Editing ChannelFeature `json:"editing,omitempty"`

	// MaxCharsCount Maximum number of characters in a text message
	MaxCharsCount *uint16 `json:"max_chars_count,omitempty"`

	// Quoting Support for operation with messages of the given type
	Quoting ChannelFeature `json:"quoting,omitempty"`

	// Reaction Support for operation with messages of the given type
	Reaction ChannelFeature `json:"reaction,omitempty"`
}

// UpdateCommandRequestBody Represents a request body for updating a new command
type UpdateCommandRequestBody struct {
	// Description Human-readable description of the command's purpose or behavior
	Description string `binding:"omitempty,min=0,max=64" json:"description"`

	// Name Unique identifier for the command
	Name string `json:"name,omitempty"`
}

// UserListResponseItem User object containing profile data, activity status and timestamps
type UserListResponseItem struct {
	// Available Indicates if the user is available for communication
	Available bool `json:"available"`

	// Avatar URL of the user's avatar
	Avatar *string `json:"avatar_url,omitempty"`

	// Connected Indicates if the user has ever connected to the system
	Connected bool `json:"connected"`

	// CreatedAt Date and time in RFC 3339 format with microseconds
	CreatedAt DateTimeRFC3339Micro `json:"created_at"`

	// ExternalID External identifier of the user (e.g. from external system)
	ExternalID *string `json:"external_id,omitempty"`

	// FirstName First name of the user
	FirstName *string `json:"first_name,omitempty"`

	// ID Internal user ID
	ID int64 `json:"id"`

	// IsActive Flag indicating if the user is marked as active
	IsActive bool `json:"is_active"`

	// IsOnline Flag indicating if the user is currently online
	IsOnline bool `json:"is_online"`

	// IsTechnicalAccount Indicates if the user is a technical (system) account
	IsTechnicalAccount bool `json:"is_technical_account"`

	// LastName Last name of the user
	LastName *string `json:"last_name,omitempty"`

	// RevokedAt Date and time in RFC 3339 format with microseconds
	RevokedAt *DateTimeRFC3339Micro `json:"revoked_at"`

	// UpdatedAt Date and time in RFC 3339 format with microseconds
	UpdatedAt *DateTimeRFC3339Micro `json:"updated_at"`

	// Username Username or login name of the user
	Username *string `json:"username,omitempty"`
}

// Utm UTM parameters for tracking marketing campaigns
type Utm struct {
	// Campaign Campaign
	Campaign *string `binding:"omitempty,min=1,max=255" json:"campaign,omitempty"`

	// Content Ad content
	Content *string `binding:"omitempty,min=1,max=255" json:"content,omitempty"`

	// Medium Medium
	Medium *string `binding:"omitempty,min=1,max=255" json:"medium,omitempty"`

	// Source Source
	Source *string `binding:"omitempty,min=1,max=255" json:"source,omitempty"`

	// Term Keyword
	Term *string `binding:"omitempty,min=1,max=255" json:"term,omitempty"`
}

// WAChannelProperties WhatsApp channel properties
type WAChannelProperties struct {
	ChannelQuality *WAChannelQuality `binding:"omitempty,enum-valid" json:"channel_quality,omitempty"`
	ChannelStatus  *WAChannelStatus  `binding:"omitempty,enum-valid" json:"channel_status,omitempty"`
	Tier           *int              `binding:"omitempty,min=0" json:"tier,omitempty"`
}

// WAChannelQuality WhatsApp channel quality
type WAChannelQuality string

// WAChannelStatus WhatsApp channel status
type WAChannelStatus string

// BotActiveQuery Boolean type
type BotActiveQuery = Boolean

// BotRoleQuery Bot role types array
type BotRoleQuery = Roles

// ChannelActiveQuery Boolean type
type ChannelActiveQuery = Boolean

// ChannelTypeQuery defines model for ChannelTypeQuery.
type ChannelTypeQuery = []ChannelType

// ChatIdPath defines model for ChatIdPath.
type ChatIdPath = int64

// CommandNamePath defines model for CommandNamePath.
type CommandNamePath = string

// DialogIdPath defines model for DialogIdPath.
type DialogIdPath = int64

// FileIdPath defines model for FileIdPath.
type FileIdPath = openapi_types.UUID

// ID defines model for IDQuery.
type ID = int

// LimitQuery defines model for LimitQuery.
type LimitQuery = int

// MessageIdPath defines model for MessageIdPath.
type MessageIdPath = int64

// SelfQuery Boolean type
type SelfQuery = Boolean

// SinceID defines model for SinceIDQuery.
type SinceID = int64

// SinceQuery defines model for SinceQuery.
type SinceQuery = time.Time

// UntilID defines model for UntilIDQuery.
type UntilID = int64

// UntilQuery defines model for UntilQuery.
type UntilQuery = time.Time

// BotsListResponse defines model for BotsListResponse.
type BotsListResponse = []Bot

// ChannelsListResponse defines model for ChannelsListResponse.
type ChannelsListResponse = []ChannelListResponseItem

// ChatMemberListResponse defines model for ChatMemberListResponse.
type ChatMemberListResponse = []ChatMemberListResponseItem

// ChatsListResponse defines model for ChatsListResponse.
type ChatsListResponse = []ChatsListResponseItem

// CommandCreateResponse Represents a created command with metadata
type CommandCreateResponse = CommandCreate

// CommandsResponse defines model for CommandsResponse.
type CommandsResponse = []Command

// CreateDialogResponse defines model for CreateDialogResponse.
type CreateDialogResponse struct {
	// CreatedAt Date and time in RFC 3339 format with microseconds
	CreatedAt DateTimeRFC3339Micro `json:"created_at"`

	// ID Unique identifier of the created dialog
	ID int64 `json:"id"`
}

// CustomersListResponse defines model for CustomersListResponse.
type CustomersListResponse = []Customer

// DialogAssignResponse defines model for DialogAssignResponse.
type DialogAssignResponse struct {
	// IsReAssign Indicates if the assignment is a reassignment
	IsReAssign bool `json:"is_reassign"`

	// LeftUserID ID of the user who left the dialog, if applicable
	LeftUserID *int64 `json:"left_user_id"`

	// PreviousResponsible Previously responsible user before reassignment
	PreviousResponsible *Responsible `json:"previous_responsible"`

	// Responsible Currently responsible user for the dialog
	Responsible Responsible `json:"responsible"`
}

// DialogUnassignResponse defines model for DialogUnassignResponse.
type DialogUnassignResponse struct {
	// PreviousResponsible Previously responsible user before unassignment
	PreviousResponsible *Responsible `json:"previous_responsible,omitempty"`
}

// DialogsListResponse defines model for DialogsListResponse.
type DialogsListResponse = []DialogListResponseItem

// EmptyResponse defines model for EmptyResponse.
type EmptyResponse = map[string]interface{}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Errors List of errors
	Errors []string `json:"errors,omitempty"`
}

// FullFileResponse Uploaded file metadata with a temporary access URL
type FullFileResponse = FileWithUrl

// MessageListResponse defines model for MessageListResponse.
type MessageListResponse = []MessageListResponseItem

// SendMessageResponse defines model for SendMessageResponse.
type SendMessageResponse struct {
	MessageId int64     `json:"message_id"`
	Time      time.Time `json:"time" time_format:"2006-01-02T15:04:05.999999Z07:00"`
}

// UploadResponse Metadata and processing status of an uploaded file
type UploadResponse = File

// UserListResponse defines model for UserListResponse.
type UserListResponse = []UserListResponseItem

// CreateDialogRequest defines model for CreateDialogRequest.
type CreateDialogRequest struct {
	// BotID ID of the bot to associate with the dialog
	BotID *int64 `binding:"omitempty,min=1" json:"bot_id"`

	// UserID ID of the user starting the dialog
	UserID *int64 `binding:"omitempty,min=1" json:"user_id"`
}

// CreateOrUpdateCommandRequest defines model for CreateOrUpdateCommandRequest.
type CreateOrUpdateCommandRequest struct {
	union json.RawMessage
}

// DialogAddTagsRequest defines model for DialogAddTagsRequest.
type DialogAddTagsRequest struct {
	// Tags List of tags to add
	Tags []struct {
		// ColorCode Optional color code for the tag
		ColorCode *ColorCode `binding:"omitempty,enum-valid" json:"color_code,omitempty"`

		// Name Name of the tag
		Name string `binding:"required,min=1,max=255" json:"name"`
	} `binding:"required,min=1,dive" json:"tags"`
}

// DialogDeleteTagsRequest defines model for DialogDeleteTagsRequest.
type DialogDeleteTagsRequest struct {
	Tags []struct {
		// Name Name of the tag to delete
		Name string `binding:"required,min=1,max=255" json:"name"`
	} `binding:"required,min=1,dive" json:"tags"`
}

// DialogResponsibleRequest defines model for DialogResponsibleRequest.
type DialogResponsibleRequest struct {
	// BotID Unique identifier of the bot assigned to the dialog
	BotID int64 `binding:"omitempty,min=1" json:"bot_id"`

	// UserID Unique identifier of the user to assign as responsible
	UserID int64 `binding:"omitempty,min=1" json:"user_id"`
}

// EditMessageRequest Represents the payload of a message, including content, attachments, and related metadata depending on the message type
type EditMessageRequest struct {
	// Content Message text content (required for text messages only)
	Content *string `json:"content,omitempty"`

	// Items File attachments (required for file, audio and image messages)
	Items *[]struct {
		// Caption Caption for the file
		Caption *string `binding:"min=1,max=1024" json:"caption,omitempty"`

		// ID Unique identifier of the file
		ID openapi_types.UUID `json:"id"`
	} `json:"items,omitempty"`

	// Note Note or description for the file (required for file, audio and image messages)
	Note *string `json:"note,omitempty"`

	// Order Order data (required for order messages only)
	Order *MessageOrder `json:"order,omitempty"`

	// Product Product data (required for product messages only)
	Product *MessageProduct `json:"product,omitempty"`

	// QuoteMessageId ID of the quoted message (required for text messages only)
	QuoteMessageId int64 `json:"quote_message_id,omitempty"`
}

// SendMessageRequest Represents the payload of a message, including content, attachments, and related metadata depending on the message type
type SendMessageRequest = SendMessageRequestBody

// UpdateBotRequest defines model for UpdateBotRequest.
type UpdateBotRequest struct {
	// AvatarUrl URL of bot avatar
	AvatarUrl *string `binding:"omitempty,url" json:"avatar_url"`

	// Name Bot name
	Name string `binding:"omitempty,min=0,max=255" json:"name"`

	// Roles Bot role types array
	Roles Roles `binding:"omitempty,enum-valid" json:"roles,omitempty"`
}

// UpdateFileMetadataRequest defines model for UpdateFileMetadataRequest.
type UpdateFileMetadataRequest struct {
	// Transcription Updated transcription text associated with the file
	Transcription string `json:"transcription"`

	// TranscriptionStatus Current status of the file transcription process
	TranscriptionStatus *FileTranscriptionStatus `binding:"oneof=in_progress ready error" json:"transcription_status,omitempty"`
}

// UploadFileByUrlRequest defines model for UploadFileByUrlRequest.
type UploadFileByUrlRequest struct {
	// Url The URL of the file to download and upload
	Url string `binding:"web_url" json:"url"`
}

// ListBotsParams defines parameters for ListBots.
type ListBotsParams struct {
	// ID Identifier of the requested object
	ID ID `binding:"omitempty,min=1" form:"id,omitempty" json:"id,omitempty"`

	// Self Filter to include only the current bot
	Self *SelfQuery `form:"self,omitempty" json:"self,omitempty"`

	// Active Filters bots by activity status
	Active *BotActiveQuery `binding:"omitempty,enum-valid" form:"active,omitempty" json:"active,omitempty"`

	// Role Filters bots by one or more assigned roles
	Role BotRoleQuery `binding:"omitempty,enum-valid" form:"role,omitempty" json:"role,omitempty"`

	// Since Lower limit of the date of the last object update
	Since SinceQuery `form:"since,omitempty" json:"since,omitempty"`

	// SinceID Lower bound for object identifiers
	SinceID SinceID `binding:"omitempty,min=1" form:"since_id,omitempty" json:"since_id,omitempty"`

	// Until Upper limit of the date of the last object update
	Until UntilQuery `form:"until,omitempty" json:"until,omitempty"`

	// UntilID Upper bound for object identifiers
	UntilID UntilID `binding:"omitempty,min=1" form:"until_id,omitempty" json:"until_id,omitempty"`

	// Limit The number of elements in the response. Default value is 100
	Limit LimitQuery `binding:"omitempty,min=1,max=1000" form:"limit,omitempty" json:"limit,omitempty"`
}

// ListChannelsParams defines parameters for ListChannels.
type ListChannelsParams struct {
	// ID Identifier of the requested object
	ID ID `binding:"omitempty,min=1" form:"id,omitempty" json:"id,omitempty"`

	// Types Filters channels by one or more specified types
	Types ChannelTypeQuery `binding:"omitempty,enum-valid" form:"types,omitempty" json:"types,omitempty"`

	// Active Filters channels by activity status
	Active *ChannelActiveQuery `binding:"omitempty,enum-valid" form:"active,omitempty" json:"active,omitempty"`

	// Since Lower limit of the date of the last object update
	Since SinceQuery `form:"since,omitempty" json:"since,omitempty"`

	// SinceID Lower bound for object identifiers
	SinceID SinceID `binding:"omitempty,min=1" form:"since_id,omitempty" json:"since_id,omitempty"`

	// Until Upper limit of the date of the last object update
	Until UntilQuery `form:"until,omitempty" json:"until,omitempty"`

	// UntilID Upper bound for object identifiers
	UntilID UntilID `binding:"omitempty,min=1" form:"until_id,omitempty" json:"until_id,omitempty"`

	// Limit The number of elements in the response. Default value is 100
	Limit LimitQuery `binding:"omitempty,min=1,max=1000" form:"limit,omitempty" json:"limit,omitempty"`
}

// ListChatsParams defines parameters for ListChats.
type ListChatsParams struct {
	// ID Identifier of the requested object
	ID ID `binding:"omitempty,min=1" form:"id,omitempty" json:"id,omitempty"`

	// Since Lower limit of the date of the last object update
	Since SinceQuery `form:"since,omitempty" json:"since,omitempty"`

	// Until Upper limit of the date of the last object update
	Until UntilQuery `form:"until,omitempty" json:"until,omitempty"`

	// Limit The number of elements in the response. Default value is 100
	Limit LimitQuery `binding:"omitempty,min=1,max=1000" form:"limit,omitempty" json:"limit,omitempty"`

	// SinceID Lower bound for object identifiers
	SinceID SinceID `binding:"omitempty,min=1" form:"since_id,omitempty" json:"since_id,omitempty"`

	// UntilID Upper bound for object identifiers
	UntilID UntilID `binding:"omitempty,min=1" form:"until_id,omitempty" json:"until_id,omitempty"`

	// ChannelID Filter by channel ID
	ChannelID *int `binding:"omitempty,min=1" form:"channel_id,omitempty" json:"channel_id,omitempty"`

	// ChannelType Filter by channel type
	ChannelType *ChannelType `binding:"omitempty,enum-valid" form:"channel_type,omitempty" json:"channel_type,omitempty"`

	// CustomerID Filter by customer ID
	CustomerID *int `binding:"omitempty,min=1" form:"customer_id,omitempty" json:"customer_id,omitempty"`

	// CustomerExternalID Filter by external customer ID
	CustomerExternalID *string `binding:"omitempty,min=1" form:"customer_external_id,omitempty" json:"customer_external_id,omitempty"`

	// IncludeMassCommunication Whether to include mass communication chats
	IncludeMassCommunication *Boolean `binding:"omitempty,enum-valid" form:"include_mass_communication,omitempty" json:"include_mass_communication,omitempty"`
}

// CreateDialogJSONBody defines parameters for CreateDialog.
type CreateDialogJSONBody struct {
	// BotID ID of the bot to associate with the dialog
	BotID *int64 `binding:"omitempty,min=1" json:"bot_id"`

	// UserID ID of the user starting the dialog
	UserID *int64 `binding:"omitempty,min=1" json:"user_id"`
}

// ListCustomersParams defines parameters for ListCustomers.
type ListCustomersParams struct {
	// ID Identifier of the requested object
	ID ID `binding:"omitempty,min=1" form:"id,omitempty" json:"id,omitempty"`

	// Since Lower limit of the date of the last object update
	Since SinceQuery `form:"since,omitempty" json:"since,omitempty"`

	// Until Upper limit of the date of the last object update
	Until UntilQuery `form:"until,omitempty" json:"until,omitempty"`

	// SinceID Lower bound for object identifiers
	SinceID SinceID `binding:"omitempty,min=1" form:"since_id,omitempty" json:"since_id,omitempty"`

	// UntilID Upper bound for object identifiers
	UntilID UntilID `binding:"omitempty,min=1" form:"until_id,omitempty" json:"until_id,omitempty"`

	// Limit The number of elements in the response. Default value is 100
	Limit LimitQuery `binding:"omitempty,min=1,max=1000" form:"limit,omitempty" json:"limit,omitempty"`

	// ChannelID Channel ID
	ChannelID int `binding:"omitempty,min=1" form:"channel_id,omitempty" json:"channel_id,omitempty"`

	// ChannelType Channel type
	ChannelType *ChannelType `binding:"omitempty,enum-valid" form:"channel_type,omitempty" json:"channel_type,omitempty"`

	// ExternalID External ID
	ExternalID string `form:"external_id,omitempty" json:"external_id,omitempty"`
}

// ListDialogsParams defines parameters for ListDialogs.
type ListDialogsParams struct {
	// ID Identifier of the requested object
	ID ID `binding:"omitempty,min=1" form:"id,omitempty" json:"id,omitempty"`

	// Since Lower limit of the date of the last object update
	Since SinceQuery `form:"since,omitempty" json:"since,omitempty"`

	// Until Upper limit of the date of the last object update
	Until UntilQuery `form:"until,omitempty" json:"until,omitempty"`

	// SinceID Lower bound for object identifiers
	SinceID SinceID `binding:"omitempty,min=1" form:"since_id,omitempty" json:"since_id,omitempty"`

	// UntilID Upper bound for object identifiers
	UntilID UntilID `binding:"omitempty,min=1" form:"until_id,omitempty" json:"until_id,omitempty"`

	// Limit The number of elements in the response. Default value is 100
	Limit LimitQuery `binding:"omitempty,min=1,max=1000" form:"limit,omitempty" json:"limit,omitempty"`

	// ChatID Chat ID
	ChatID int `binding:"omitempty,min=1" form:"chat_id,omitempty" json:"chat_id,omitempty"`

	// UserID User ID
	UserID int `binding:"omitempty,min=1" form:"user_id,omitempty" json:"user_id,omitempty"`

	// BotID Bot ID
	BotID int `binding:"omitempty,min=1" form:"bot_id,omitempty" json:"bot_id,omitempty"`

	// Active Activity flag
	Active *Boolean `binding:"omitempty,enum-valid" form:"active,omitempty" json:"active,omitempty"`

	// Assign Should assign
	Assign *Boolean `binding:"omitempty,enum-valid" form:"assign,omitempty" json:"assign,omitempty"`

	// IncludeMassCommunication With mass communications
	IncludeMassCommunication *Boolean `binding:"omitempty,enum-valid" form:"include_mass_communication,omitempty" json:"include_mass_communication,omitempty"`
}

// AssignDialogResponsibleJSONBody defines parameters for AssignDialogResponsible.
type AssignDialogResponsibleJSONBody struct {
	// BotID Unique identifier of the bot assigned to the dialog
	BotID int64 `binding:"omitempty,min=1" json:"bot_id"`

	// UserID Unique identifier of the user to assign as responsible
	UserID int64 `binding:"omitempty,min=1" json:"user_id"`
}

// DialogAddTagsJSONBody defines parameters for DialogAddTags.
type DialogAddTagsJSONBody struct {
	// Tags List of tags to add
	Tags []struct {
		// ColorCode Optional color code for the tag
		ColorCode *ColorCode `binding:"omitempty,enum-valid" json:"color_code,omitempty"`

		// Name Name of the tag
		Name string `binding:"required,min=1,max=255" json:"name"`
	} `binding:"required,min=1,dive" json:"tags"`
}

// DialogDeleteTagsJSONBody defines parameters for DialogDeleteTags.
type DialogDeleteTagsJSONBody struct {
	Tags []struct {
		// Name Name of the tag to delete
		Name string `binding:"required,min=1,max=255" json:"name"`
	} `binding:"required,min=1,dive" json:"tags"`
}

// UploadFileMultipartBody defines parameters for UploadFile.
type UploadFileMultipartBody struct {
	// File Binary file data to upload (e.g. image, document, video)
	File openapi_types.File `json:"file"`
}

// UploadFileByUrlJSONBody defines parameters for UploadFileByUrl.
type UploadFileByUrlJSONBody struct {
	// Url The URL of the file to download and upload
	Url string `binding:"web_url" json:"url"`
}

// UpdateFileMetadataJSONBody defines parameters for UpdateFileMetadata.
type UpdateFileMetadataJSONBody struct {
	// Transcription Updated transcription text associated with the file
	Transcription string `json:"transcription"`

	// TranscriptionStatus Current status of the file transcription process
	TranscriptionStatus *FileTranscriptionStatus `binding:"oneof=in_progress ready error" json:"transcription_status,omitempty"`
}

// ListMembersParams defines parameters for ListMembers.
type ListMembersParams struct {
	// ID Identifier of the requested object
	ID ID `binding:"omitempty,min=1" form:"id,omitempty" json:"id,omitempty"`

	// Since Lower limit of the date of the last object update
	Since SinceQuery `form:"since,omitempty" json:"since,omitempty"`

	// Until Upper limit of the date of the last object update
	Until UntilQuery `form:"until,omitempty" json:"until,omitempty"`

	// SinceID Lower bound for object identifiers
	SinceID SinceID `binding:"omitempty,min=1" form:"since_id,omitempty" json:"since_id,omitempty"`

	// UntilID Upper bound for object identifiers
	UntilID UntilID `binding:"omitempty,min=1" form:"until_id,omitempty" json:"until_id,omitempty"`

	// Limit The number of elements in the response. Default value is 100
	Limit LimitQuery `binding:"omitempty,min=1,max=1000" form:"limit,omitempty" json:"limit,omitempty"`

	// ChatID Filter by chat identifier
	ChatID int `binding:"omitempty,min=1" form:"chat_id,omitempty" json:"chat_id,omitempty"`

	// UserID Filter by user identifier
	UserID int `binding:"omitempty,min=1" form:"user_id,omitempty" json:"user_id,omitempty"`

	// State Filter by member state
	State ListMembersParamsState `binding:"omitempty,oneof=active kicked leaved" form:"state,omitempty" json:"state,omitempty"`
}

// ListMembersParamsState defines parameters for ListMembers.
type ListMembersParamsState string

// ListMessagesParams defines parameters for ListMessages.
type ListMessagesParams struct {
	// Since Lower limit of the date of the last object update
	Since SinceQuery `form:"since,omitempty" json:"since,omitempty"`

	// Until Upper limit of the date of the last object update
	Until UntilQuery `form:"until,omitempty" json:"until,omitempty"`

	// SinceID Lower bound for object identifiers
	SinceID SinceID `binding:"omitempty,min=1" form:"since_id,omitempty" json:"since_id,omitempty"`

	// UntilID Upper bound for object identifiers
	UntilID UntilID `binding:"omitempty,min=1" form:"until_id,omitempty" json:"until_id,omitempty"`

	// Limit The number of elements in the response. Default value is 100
	Limit LimitQuery `binding:"omitempty,min=1,max=1000" form:"limit,omitempty" json:"limit,omitempty"`

	// ID Filter by a list of message IDs
	ID []int64 `binding:"omitempty,dive,min=1" form:"id,omitempty" json:"id,omitempty"`

	// ChatID Filter by chat ID
	ChatID int64 `binding:"omitempty,min=1" form:"chat_id,omitempty" json:"chat_id,omitempty"`

	// UserID Filter by user ID
	UserID int64 `binding:"omitempty,min=1" form:"user_id,omitempty" json:"user_id,omitempty"`

	// CustomerID Filter by customer ID
	CustomerID int64 `binding:"omitempty,min=1" form:"customer_id,omitempty" json:"customer_id,omitempty"`

	// BotID Filter by bot ID
	BotID int64 `binding:"omitempty,min=1" form:"bot_id,omitempty" json:"bot_id,omitempty"`

	// DialogID Filter by dialog ID
	DialogID int64 `binding:"omitempty,min=1" form:"dialog_id,omitempty" json:"dialog_id,omitempty"`

	// ChannelID Filter by channel ID
	ChannelID int64 `binding:"omitempty,min=1" form:"channel_id,omitempty" json:"channel_id,omitempty"`

	// ChannelType Filter by channel type
	ChannelType *ChannelType `binding:"omitempty,enum-valid" form:"channel_type,omitempty" json:"channel_type,omitempty"`

	// Type Filter by message type
	Type *MessageType `binding:"omitempty,oneof=text system file image order product command audio" form:"type,omitempty" json:"type,omitempty"`

	// IncludeMassCommunication Whether to include mass communication messages
	IncludeMassCommunication *Boolean `binding:"omitempty,enum-valid" form:"include_mass_communication,omitempty" json:"include_mass_communication,omitempty"`

	// Scope Filter by message scope (public or private)
	Scope *ListMessagesParamsScope `binding:"omitempty,oneof=public private" form:"scope,omitempty" json:"scope,omitempty"`
}

// ListMessagesParamsScope defines parameters for ListMessages.
type ListMessagesParamsScope string

// EditMessageJSONBody defines parameters for EditMessage.
type EditMessageJSONBody struct {
	// Content Message text content (required for text messages only)
	Content *string `json:"content,omitempty"`

	// Items File attachments (required for file, audio and image messages)
	Items *[]struct {
		// Caption Caption for the file
		Caption *string `binding:"min=1,max=1024" json:"caption,omitempty"`

		// ID Unique identifier of the file
		ID openapi_types.UUID `json:"id"`
	} `json:"items,omitempty"`

	// Note Note or description for the file (required for file, audio and image messages)
	Note *string `json:"note,omitempty"`

	// Order Order data (required for order messages only)
	Order *MessageOrder `json:"order,omitempty"`

	// Product Product data (required for product messages only)
	Product *MessageProduct `json:"product,omitempty"`

	// QuoteMessageId ID of the quoted message (required for text messages only)
	QuoteMessageId int64 `json:"quote_message_id,omitempty"`
}

// ListCommandsParams defines parameters for ListCommands.
type ListCommandsParams struct {
	// ID Identifier of the requested object
	ID ID `binding:"omitempty,min=1" form:"id,omitempty" json:"id,omitempty"`

	// Limit The number of elements in the response. Default value is 100
	Limit LimitQuery `binding:"omitempty,min=1,max=1000" form:"limit,omitempty" json:"limit,omitempty"`

	// SinceID Lower bound for object identifiers
	SinceID SinceID `binding:"omitempty,min=1" form:"since_id,omitempty" json:"since_id,omitempty"`

	// Since Lower limit of the date of the last object update
	Since SinceQuery `form:"since,omitempty" json:"since,omitempty"`

	// UntilID Upper bound for object identifiers
	UntilID UntilID `binding:"omitempty,min=1" form:"until_id,omitempty" json:"until_id,omitempty"`

	// Until Upper limit of the date of the last object update
	Until UntilQuery `form:"until,omitempty" json:"until,omitempty"`

	// Name Filter commands by name
	Name string `binding:"omitempty,max=32,command_name" form:"name,omitempty" json:"name,omitempty"`
}

// CreateOrUpdateCommandJSONBody defines parameters for CreateOrUpdateCommand.
type CreateOrUpdateCommandJSONBody struct {
	union json.RawMessage
}

// UpdateBotJSONBody defines parameters for UpdateBot.
type UpdateBotJSONBody struct {
	// AvatarUrl URL of bot avatar
	AvatarUrl *string `binding:"omitempty,url" json:"avatar_url"`

	// Name Bot name
	Name string `binding:"omitempty,min=0,max=255" json:"name"`

	// Roles Bot role types array
	Roles Roles `binding:"omitempty,enum-valid" json:"roles,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// ID Identifier of the requested object
	ID ID `binding:"omitempty,min=1" form:"id,omitempty" json:"id,omitempty"`

	// Since Lower limit of the date of the last object update
	Since SinceQuery `form:"since,omitempty" json:"since,omitempty"`

	// Until Upper limit of the date of the last object update
	Until UntilQuery `form:"until,omitempty" json:"until,omitempty"`

	// SinceID Lower bound for object identifiers
	SinceID SinceID `binding:"omitempty,min=1" form:"since_id,omitempty" json:"since_id,omitempty"`

	// UntilID Upper bound for object identifiers
	UntilID UntilID `binding:"omitempty,min=1" form:"until_id,omitempty" json:"until_id,omitempty"`

	// Limit The number of elements in the response. Default value is 100
	Limit LimitQuery `binding:"omitempty,min=1,max=1000" form:"limit,omitempty" json:"limit,omitempty"`

	// Active Filter users by activity status
	Active *Boolean `binding:"omitempty,enum-valid" form:"active,omitempty" json:"active,omitempty"`

	// Online Filter users by online status
	Online *Boolean `binding:"omitempty,enum-valid" form:"online,omitempty" json:"online,omitempty"`

	// ExternalID Filter users by external identifier
	ExternalID *string `form:"external_id,omitempty" json:"external_id,omitempty"`
}

// WebSocketConnectionParams defines parameters for WebSocketConnection.
type WebSocketConnectionParams struct {
	// Events Comma-separated list of events to subscribe to via WebSocket (message_new, message_updated, message_restored, message_deleted, dialog_opened, dialog_closed, dialog_assign, chat_created, chat_updated, chats_deleted, user_joined_chat, user_left_chat, user_updated, user_online_updated, channel_updated, customer_updated, bot_updated)
	Events string `binding:"required" form:"events,omitempty" json:"events,omitempty"`

	// Options Additional WebSocket connection parameters (include_mass_communication  allow receiving events for messages sent via mass mailing actions)
	Options string `binding:"omitempty" form:"options,omitempty" json:"options,omitempty"`
}

// CreateDialogJSONRequestBody defines body for CreateDialog for application/json ContentType.
type CreateDialogJSONRequestBody CreateDialogJSONBody

// AssignDialogResponsibleJSONRequestBody defines body for AssignDialogResponsible for application/json ContentType.
type AssignDialogResponsibleJSONRequestBody AssignDialogResponsibleJSONBody

// DialogAddTagsJSONRequestBody defines body for DialogAddTags for application/json ContentType.
type DialogAddTagsJSONRequestBody DialogAddTagsJSONBody

// DialogDeleteTagsJSONRequestBody defines body for DialogDeleteTags for application/json ContentType.
type DialogDeleteTagsJSONRequestBody DialogDeleteTagsJSONBody

// UploadFileMultipartRequestBody defines body for UploadFile for multipart/form-data ContentType.
type UploadFileMultipartRequestBody UploadFileMultipartBody

// UploadFileByUrlJSONRequestBody defines body for UploadFileByUrl for application/json ContentType.
type UploadFileByUrlJSONRequestBody UploadFileByUrlJSONBody

// UpdateFileMetadataJSONRequestBody defines body for UpdateFileMetadata for application/json ContentType.
type UpdateFileMetadataJSONRequestBody UpdateFileMetadataJSONBody

// SendMessageJSONRequestBody defines body for SendMessage for application/json ContentType.
type SendMessageJSONRequestBody = SendMessageRequestBody

// EditMessageJSONRequestBody defines body for EditMessage for application/json ContentType.
type EditMessageJSONRequestBody EditMessageJSONBody

// CreateOrUpdateCommandJSONRequestBody defines body for CreateOrUpdateCommand for application/json ContentType.
type CreateOrUpdateCommandJSONRequestBody CreateOrUpdateCommandJSONBody

// UpdateBotJSONRequestBody defines body for UpdateBot for application/json ContentType.
type UpdateBotJSONRequestBody UpdateBotJSONBody

// AsCreateCommandRequestBody returns the union data inside the CreateOrUpdateCommandRequest as a CreateCommandRequestBody
func (t CreateOrUpdateCommandRequest) AsCreateCommandRequestBody() (CreateCommandRequestBody, error) {
	var body CreateCommandRequestBody
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCommandRequestBody overwrites any union data inside the CreateOrUpdateCommandRequest as the provided CreateCommandRequestBody
func (t *CreateOrUpdateCommandRequest) FromCreateCommandRequestBody(v CreateCommandRequestBody) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCommandRequestBody performs a merge with any union data inside the CreateOrUpdateCommandRequest, using the provided CreateCommandRequestBody
func (t *CreateOrUpdateCommandRequest) MergeCreateCommandRequestBody(v CreateCommandRequestBody) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateCommandRequestBody returns the union data inside the CreateOrUpdateCommandRequest as a UpdateCommandRequestBody
func (t CreateOrUpdateCommandRequest) AsUpdateCommandRequestBody() (UpdateCommandRequestBody, error) {
	var body UpdateCommandRequestBody
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateCommandRequestBody overwrites any union data inside the CreateOrUpdateCommandRequest as the provided UpdateCommandRequestBody
func (t *CreateOrUpdateCommandRequest) FromUpdateCommandRequestBody(v UpdateCommandRequestBody) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateCommandRequestBody performs a merge with any union data inside the CreateOrUpdateCommandRequest, using the provided UpdateCommandRequestBody
func (t *CreateOrUpdateCommandRequest) MergeUpdateCommandRequestBody(v UpdateCommandRequestBody) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateOrUpdateCommandRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateOrUpdateCommandRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListBots request
	ListBots(ctx context.Context, params *ListBotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListChannels request
	ListChannels(ctx context.Context, params *ListChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListChats request
	ListChats(ctx context.Context, params *ListChatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDialogWithBody request with any body
	CreateDialogWithBody(ctx context.Context, chatId ChatIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDialog(ctx context.Context, chatId ChatIdPath, body CreateDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomers request
	ListCustomers(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDialogs request
	ListDialogs(ctx context.Context, params *ListDialogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignDialogResponsibleWithBody request with any body
	AssignDialogResponsibleWithBody(ctx context.Context, dialogId DialogIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignDialogResponsible(ctx context.Context, dialogId DialogIdPath, body AssignDialogResponsibleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloseDialog request
	CloseDialog(ctx context.Context, dialogId DialogIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DialogAddTagsWithBody request with any body
	DialogAddTagsWithBody(ctx context.Context, dialogId DialogIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DialogAddTags(ctx context.Context, dialogId DialogIdPath, body DialogAddTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DialogDeleteTagsWithBody request with any body
	DialogDeleteTagsWithBody(ctx context.Context, dialogId DialogIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DialogDeleteTags(ctx context.Context, dialogId DialogIdPath, body DialogDeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignDialogResponsible request
	UnassignDialogResponsible(ctx context.Context, dialogId DialogIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadFileWithBody request with any body
	UploadFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadFileByUrlWithBody request with any body
	UploadFileByUrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadFileByUrl(ctx context.Context, body UploadFileByUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFileUrl request
	GetFileUrl(ctx context.Context, id FileIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFileMetadataWithBody request with any body
	UpdateFileMetadataWithBody(ctx context.Context, id FileIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFileMetadata(ctx context.Context, id FileIdPath, body UpdateFileMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMembers request
	ListMembers(ctx context.Context, params *ListMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMessages request
	ListMessages(ctx context.Context, params *ListMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendMessageWithBody request with any body
	SendMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendMessage(ctx context.Context, body SendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMessage request
	DeleteMessage(ctx context.Context, messageId MessageIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditMessageWithBody request with any body
	EditMessageWithBody(ctx context.Context, messageId MessageIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditMessage(ctx context.Context, messageId MessageIdPath, body EditMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCommands request
	ListCommands(ctx context.Context, params *ListCommandsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCommand request
	DeleteCommand(ctx context.Context, commandName CommandNamePath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateCommandWithBody request with any body
	CreateOrUpdateCommandWithBody(ctx context.Context, commandName CommandNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateCommand(ctx context.Context, commandName CommandNamePath, body CreateOrUpdateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBotWithBody request with any body
	UpdateBotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBot(ctx context.Context, body UpdateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebSocketConnection request
	WebSocketConnection(ctx context.Context, params *WebSocketConnectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListBots(ctx context.Context, params *ListBotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBotsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListChannels(ctx context.Context, params *ListChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListChats(ctx context.Context, params *ListChatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListChatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDialogWithBody(ctx context.Context, chatId ChatIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDialogRequestWithBody(c.Server, chatId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDialog(ctx context.Context, chatId ChatIdPath, body CreateDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDialogRequest(c.Server, chatId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomers(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDialogs(ctx context.Context, params *ListDialogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDialogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignDialogResponsibleWithBody(ctx context.Context, dialogId DialogIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignDialogResponsibleRequestWithBody(c.Server, dialogId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignDialogResponsible(ctx context.Context, dialogId DialogIdPath, body AssignDialogResponsibleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignDialogResponsibleRequest(c.Server, dialogId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloseDialog(ctx context.Context, dialogId DialogIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloseDialogRequest(c.Server, dialogId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DialogAddTagsWithBody(ctx context.Context, dialogId DialogIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDialogAddTagsRequestWithBody(c.Server, dialogId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DialogAddTags(ctx context.Context, dialogId DialogIdPath, body DialogAddTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDialogAddTagsRequest(c.Server, dialogId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DialogDeleteTagsWithBody(ctx context.Context, dialogId DialogIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDialogDeleteTagsRequestWithBody(c.Server, dialogId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DialogDeleteTags(ctx context.Context, dialogId DialogIdPath, body DialogDeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDialogDeleteTagsRequest(c.Server, dialogId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignDialogResponsible(ctx context.Context, dialogId DialogIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignDialogResponsibleRequest(c.Server, dialogId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileByUrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileByUrlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileByUrl(ctx context.Context, body UploadFileByUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileByUrlRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFileUrl(ctx context.Context, id FileIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileUrlRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFileMetadataWithBody(ctx context.Context, id FileIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFileMetadataRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFileMetadata(ctx context.Context, id FileIdPath, body UpdateFileMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFileMetadataRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMembers(ctx context.Context, params *ListMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMessages(ctx context.Context, params *ListMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMessagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessage(ctx context.Context, body SendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMessage(ctx context.Context, messageId MessageIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMessageRequest(c.Server, messageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditMessageWithBody(ctx context.Context, messageId MessageIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditMessageRequestWithBody(c.Server, messageId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditMessage(ctx context.Context, messageId MessageIdPath, body EditMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditMessageRequest(c.Server, messageId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCommands(ctx context.Context, params *ListCommandsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCommandsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCommand(ctx context.Context, commandName CommandNamePath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommandRequest(c.Server, commandName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateCommandWithBody(ctx context.Context, commandName CommandNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateCommandRequestWithBody(c.Server, commandName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateCommand(ctx context.Context, commandName CommandNamePath, body CreateOrUpdateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateCommandRequest(c.Server, commandName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBotRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBot(ctx context.Context, body UpdateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBotRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebSocketConnection(ctx context.Context, params *WebSocketConnectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebSocketConnectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListBotsRequest generates requests for ListBots
func NewListBotsRequest(server string, params *ListBotsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.ID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "self", runtime.ParamLocationQuery, params.Self); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, params.Active); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, params.Role); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_id", runtime.ParamLocationQuery, params.SinceID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, params.Until); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_id", runtime.ParamLocationQuery, params.UntilID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListChannelsRequest generates requests for ListChannels
func NewListChannelsRequest(server string, params *ListChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.ID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "types", runtime.ParamLocationQuery, params.Types); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, params.Active); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_id", runtime.ParamLocationQuery, params.SinceID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, params.Until); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_id", runtime.ParamLocationQuery, params.UntilID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListChatsRequest generates requests for ListChats
func NewListChatsRequest(server string, params *ListChatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.ID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, params.Until); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_id", runtime.ParamLocationQuery, params.SinceID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_id", runtime.ParamLocationQuery, params.UntilID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_id", runtime.ParamLocationQuery, params.ChannelID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_type", runtime.ParamLocationQuery, params.ChannelType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customer_id", runtime.ParamLocationQuery, params.CustomerID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customer_external_id", runtime.ParamLocationQuery, params.CustomerExternalID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_mass_communication", runtime.ParamLocationQuery, params.IncludeMassCommunication); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDialogRequest calls the generic CreateDialog builder with application/json body
func NewCreateDialogRequest(server string, chatId ChatIdPath, body CreateDialogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDialogRequestWithBody(server, chatId, "application/json", bodyReader)
}

// NewCreateDialogRequestWithBody generates requests for CreateDialog with any type of body
func NewCreateDialogRequestWithBody(server string, chatId ChatIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chat_id", runtime.ParamLocationPath, chatId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/%s/dialogs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCustomersRequest generates requests for ListCustomers
func NewListCustomersRequest(server string, params *ListCustomersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.ID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, params.Until); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_id", runtime.ParamLocationQuery, params.SinceID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_id", runtime.ParamLocationQuery, params.UntilID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_id", runtime.ParamLocationQuery, params.ChannelID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_type", runtime.ParamLocationQuery, params.ChannelType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "external_id", runtime.ParamLocationQuery, params.ExternalID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDialogsRequest generates requests for ListDialogs
func NewListDialogsRequest(server string, params *ListDialogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dialogs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.ID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, params.Until); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_id", runtime.ParamLocationQuery, params.SinceID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_id", runtime.ParamLocationQuery, params.UntilID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chat_id", runtime.ParamLocationQuery, params.ChatID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bot_id", runtime.ParamLocationQuery, params.BotID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, params.Active); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assign", runtime.ParamLocationQuery, params.Assign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_mass_communication", runtime.ParamLocationQuery, params.IncludeMassCommunication); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignDialogResponsibleRequest calls the generic AssignDialogResponsible builder with application/json body
func NewAssignDialogResponsibleRequest(server string, dialogId DialogIdPath, body AssignDialogResponsibleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignDialogResponsibleRequestWithBody(server, dialogId, "application/json", bodyReader)
}

// NewAssignDialogResponsibleRequestWithBody generates requests for AssignDialogResponsible with any type of body
func NewAssignDialogResponsibleRequestWithBody(server string, dialogId DialogIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dialog_id", runtime.ParamLocationPath, dialogId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dialogs/%s/assign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCloseDialogRequest generates requests for CloseDialog
func NewCloseDialogRequest(server string, dialogId DialogIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dialog_id", runtime.ParamLocationPath, dialogId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dialogs/%s/close", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDialogAddTagsRequest calls the generic DialogAddTags builder with application/json body
func NewDialogAddTagsRequest(server string, dialogId DialogIdPath, body DialogAddTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDialogAddTagsRequestWithBody(server, dialogId, "application/json", bodyReader)
}

// NewDialogAddTagsRequestWithBody generates requests for DialogAddTags with any type of body
func NewDialogAddTagsRequestWithBody(server string, dialogId DialogIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dialog_id", runtime.ParamLocationPath, dialogId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dialogs/%s/tags/add", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDialogDeleteTagsRequest calls the generic DialogDeleteTags builder with application/json body
func NewDialogDeleteTagsRequest(server string, dialogId DialogIdPath, body DialogDeleteTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDialogDeleteTagsRequestWithBody(server, dialogId, "application/json", bodyReader)
}

// NewDialogDeleteTagsRequestWithBody generates requests for DialogDeleteTags with any type of body
func NewDialogDeleteTagsRequestWithBody(server string, dialogId DialogIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dialog_id", runtime.ParamLocationPath, dialogId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dialogs/%s/tags/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignDialogResponsibleRequest generates requests for UnassignDialogResponsible
func NewUnassignDialogResponsibleRequest(server string, dialogId DialogIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dialog_id", runtime.ParamLocationPath, dialogId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dialogs/%s/unassign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadFileRequestWithBody generates requests for UploadFile with any type of body
func NewUploadFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadFileByUrlRequest calls the generic UploadFileByUrl builder with application/json body
func NewUploadFileByUrlRequest(server string, body UploadFileByUrlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadFileByUrlRequestWithBody(server, "application/json", bodyReader)
}

// NewUploadFileByUrlRequestWithBody generates requests for UploadFileByUrl with any type of body
func NewUploadFileByUrlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/upload_by_url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFileUrlRequest generates requests for GetFileUrl
func NewGetFileUrlRequest(server string, id FileIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFileMetadataRequest calls the generic UpdateFileMetadata builder with application/json body
func NewUpdateFileMetadataRequest(server string, id FileIdPath, body UpdateFileMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFileMetadataRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateFileMetadataRequestWithBody generates requests for UpdateFileMetadata with any type of body
func NewUpdateFileMetadataRequestWithBody(server string, id FileIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s/meta", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMembersRequest generates requests for ListMembers
func NewListMembersRequest(server string, params *ListMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.ID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, params.Until); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_id", runtime.ParamLocationQuery, params.SinceID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_id", runtime.ParamLocationQuery, params.UntilID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chat_id", runtime.ParamLocationQuery, params.ChatID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMessagesRequest generates requests for ListMessages
func NewListMessagesRequest(server string, params *ListMessagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, params.Until); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_id", runtime.ParamLocationQuery, params.SinceID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_id", runtime.ParamLocationQuery, params.UntilID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.ID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chat_id", runtime.ParamLocationQuery, params.ChatID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customer_id", runtime.ParamLocationQuery, params.CustomerID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bot_id", runtime.ParamLocationQuery, params.BotID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dialog_id", runtime.ParamLocationQuery, params.DialogID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_id", runtime.ParamLocationQuery, params.ChannelID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_type", runtime.ParamLocationQuery, params.ChannelType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_mass_communication", runtime.ParamLocationQuery, params.IncludeMassCommunication); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, params.Scope); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendMessageRequest calls the generic SendMessage builder with application/json body
func NewSendMessageRequest(server string, body SendMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewSendMessageRequestWithBody generates requests for SendMessage with any type of body
func NewSendMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMessageRequest generates requests for DeleteMessage
func NewDeleteMessageRequest(server string, messageId MessageIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "message_id", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditMessageRequest calls the generic EditMessage builder with application/json body
func NewEditMessageRequest(server string, messageId MessageIdPath, body EditMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditMessageRequestWithBody(server, messageId, "application/json", bodyReader)
}

// NewEditMessageRequestWithBody generates requests for EditMessage with any type of body
func NewEditMessageRequestWithBody(server string, messageId MessageIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "message_id", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCommandsRequest generates requests for ListCommands
func NewListCommandsRequest(server string, params *ListCommandsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/my/commands")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.ID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_id", runtime.ParamLocationQuery, params.SinceID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_id", runtime.ParamLocationQuery, params.UntilID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, params.Until); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCommandRequest generates requests for DeleteCommand
func NewDeleteCommandRequest(server string, commandName CommandNamePath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "command_name", runtime.ParamLocationPath, commandName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/my/commands/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateCommandRequest calls the generic CreateOrUpdateCommand builder with application/json body
func NewCreateOrUpdateCommandRequest(server string, commandName CommandNamePath, body CreateOrUpdateCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateCommandRequestWithBody(server, commandName, "application/json", bodyReader)
}

// NewCreateOrUpdateCommandRequestWithBody generates requests for CreateOrUpdateCommand with any type of body
func NewCreateOrUpdateCommandRequestWithBody(server string, commandName CommandNamePath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "command_name", runtime.ParamLocationPath, commandName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/my/commands/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateBotRequest calls the generic UpdateBot builder with application/json body
func NewUpdateBotRequest(server string, body UpdateBotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBotRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateBotRequestWithBody generates requests for UpdateBot with any type of body
func NewUpdateBotRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/my/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.ID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, params.Until); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_id", runtime.ParamLocationQuery, params.SinceID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_id", runtime.ParamLocationQuery, params.UntilID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, params.Active); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "online", runtime.ParamLocationQuery, params.Online); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "external_id", runtime.ParamLocationQuery, params.ExternalID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebSocketConnectionRequest generates requests for WebSocketConnection
func NewWebSocketConnectionRequest(server string, params *WebSocketConnectionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "events", runtime.ParamLocationQuery, params.Events); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "options", runtime.ParamLocationQuery, params.Options); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListBotsWithResponse request
	ListBotsWithResponse(ctx context.Context, params *ListBotsParams, reqEditors ...RequestEditorFn) (*ListBotsResp, error)

	// ListChannelsWithResponse request
	ListChannelsWithResponse(ctx context.Context, params *ListChannelsParams, reqEditors ...RequestEditorFn) (*ListChannelsResp, error)

	// ListChatsWithResponse request
	ListChatsWithResponse(ctx context.Context, params *ListChatsParams, reqEditors ...RequestEditorFn) (*ListChatsResp, error)

	// CreateDialogWithBodyWithResponse request with any body
	CreateDialogWithBodyWithResponse(ctx context.Context, chatId ChatIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDialogResp, error)

	CreateDialogWithResponse(ctx context.Context, chatId ChatIdPath, body CreateDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDialogResp, error)

	// ListCustomersWithResponse request
	ListCustomersWithResponse(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*ListCustomersResp, error)

	// ListDialogsWithResponse request
	ListDialogsWithResponse(ctx context.Context, params *ListDialogsParams, reqEditors ...RequestEditorFn) (*ListDialogsResp, error)

	// AssignDialogResponsibleWithBodyWithResponse request with any body
	AssignDialogResponsibleWithBodyWithResponse(ctx context.Context, dialogId DialogIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignDialogResponsibleResp, error)

	AssignDialogResponsibleWithResponse(ctx context.Context, dialogId DialogIdPath, body AssignDialogResponsibleJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignDialogResponsibleResp, error)

	// CloseDialogWithResponse request
	CloseDialogWithResponse(ctx context.Context, dialogId DialogIdPath, reqEditors ...RequestEditorFn) (*CloseDialogResp, error)

	// DialogAddTagsWithBodyWithResponse request with any body
	DialogAddTagsWithBodyWithResponse(ctx context.Context, dialogId DialogIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DialogAddTagsResp, error)

	DialogAddTagsWithResponse(ctx context.Context, dialogId DialogIdPath, body DialogAddTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DialogAddTagsResp, error)

	// DialogDeleteTagsWithBodyWithResponse request with any body
	DialogDeleteTagsWithBodyWithResponse(ctx context.Context, dialogId DialogIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DialogDeleteTagsResp, error)

	DialogDeleteTagsWithResponse(ctx context.Context, dialogId DialogIdPath, body DialogDeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DialogDeleteTagsResp, error)

	// UnassignDialogResponsibleWithResponse request
	UnassignDialogResponsibleWithResponse(ctx context.Context, dialogId DialogIdPath, reqEditors ...RequestEditorFn) (*UnassignDialogResponsibleResp, error)

	// UploadFileWithBodyWithResponse request with any body
	UploadFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileResp, error)

	// UploadFileByUrlWithBodyWithResponse request with any body
	UploadFileByUrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileByUrlResp, error)

	UploadFileByUrlWithResponse(ctx context.Context, body UploadFileByUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadFileByUrlResp, error)

	// GetFileUrlWithResponse request
	GetFileUrlWithResponse(ctx context.Context, id FileIdPath, reqEditors ...RequestEditorFn) (*GetFileUrlResp, error)

	// UpdateFileMetadataWithBodyWithResponse request with any body
	UpdateFileMetadataWithBodyWithResponse(ctx context.Context, id FileIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFileMetadataResp, error)

	UpdateFileMetadataWithResponse(ctx context.Context, id FileIdPath, body UpdateFileMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFileMetadataResp, error)

	// ListMembersWithResponse request
	ListMembersWithResponse(ctx context.Context, params *ListMembersParams, reqEditors ...RequestEditorFn) (*ListMembersResp, error)

	// ListMessagesWithResponse request
	ListMessagesWithResponse(ctx context.Context, params *ListMessagesParams, reqEditors ...RequestEditorFn) (*ListMessagesResp, error)

	// SendMessageWithBodyWithResponse request with any body
	SendMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMessageResp, error)

	SendMessageWithResponse(ctx context.Context, body SendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageResp, error)

	// DeleteMessageWithResponse request
	DeleteMessageWithResponse(ctx context.Context, messageId MessageIdPath, reqEditors ...RequestEditorFn) (*DeleteMessageResp, error)

	// EditMessageWithBodyWithResponse request with any body
	EditMessageWithBodyWithResponse(ctx context.Context, messageId MessageIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditMessageResp, error)

	EditMessageWithResponse(ctx context.Context, messageId MessageIdPath, body EditMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*EditMessageResp, error)

	// ListCommandsWithResponse request
	ListCommandsWithResponse(ctx context.Context, params *ListCommandsParams, reqEditors ...RequestEditorFn) (*ListCommandsResp, error)

	// DeleteCommandWithResponse request
	DeleteCommandWithResponse(ctx context.Context, commandName CommandNamePath, reqEditors ...RequestEditorFn) (*DeleteCommandResp, error)

	// CreateOrUpdateCommandWithBodyWithResponse request with any body
	CreateOrUpdateCommandWithBodyWithResponse(ctx context.Context, commandName CommandNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateCommandResp, error)

	CreateOrUpdateCommandWithResponse(ctx context.Context, commandName CommandNamePath, body CreateOrUpdateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateCommandResp, error)

	// UpdateBotWithBodyWithResponse request with any body
	UpdateBotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBotResp, error)

	UpdateBotWithResponse(ctx context.Context, body UpdateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBotResp, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResp, error)

	// WebSocketConnectionWithResponse request
	WebSocketConnectionWithResponse(ctx context.Context, params *WebSocketConnectionParams, reqEditors ...RequestEditorFn) (*WebSocketConnectionResp, error)
}

type ListBotsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BotsListResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListBotsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBotsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListChannelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelsListResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListChannelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListChannelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListChatsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatsListResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListChatsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListChatsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDialogResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateDialogResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateDialogResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDialogResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomersListResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListCustomersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDialogsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DialogsListResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListDialogsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDialogsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignDialogResponsibleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DialogAssignResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AssignDialogResponsibleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignDialogResponsibleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloseDialogResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CloseDialogResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloseDialogResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DialogAddTagsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DialogAddTagsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DialogAddTagsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DialogDeleteTagsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DialogDeleteTagsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DialogDeleteTagsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignDialogResponsibleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DialogUnassignResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UnassignDialogResponsibleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignDialogResponsibleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadFileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UploadFileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadFileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadFileByUrlResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UploadFileByUrlResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadFileByUrlResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileUrlResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FullFileResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetFileUrlResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileUrlResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFileMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateFileMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFileMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMembersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatMemberListResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListMembersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMembersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMessagesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageListResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListMessagesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMessagesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendMessageResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EditMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCommandsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandsResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListCommandsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCommandsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCommandResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCommandResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommandResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateCommandResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandCreateResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateCommandResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateCommandResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBotResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateBotResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBotResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserListResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListUsersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebSocketConnectionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON101      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WebSocketConnectionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebSocketConnectionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListBotsWithResponse request returning *ListBotsResp
func (c *ClientWithResponses) ListBotsWithResponse(ctx context.Context, params *ListBotsParams, reqEditors ...RequestEditorFn) (*ListBotsResp, error) {
	rsp, err := c.ListBots(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBotsResp(rsp)
}

// ListChannelsWithResponse request returning *ListChannelsResp
func (c *ClientWithResponses) ListChannelsWithResponse(ctx context.Context, params *ListChannelsParams, reqEditors ...RequestEditorFn) (*ListChannelsResp, error) {
	rsp, err := c.ListChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListChannelsResp(rsp)
}

// ListChatsWithResponse request returning *ListChatsResp
func (c *ClientWithResponses) ListChatsWithResponse(ctx context.Context, params *ListChatsParams, reqEditors ...RequestEditorFn) (*ListChatsResp, error) {
	rsp, err := c.ListChats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListChatsResp(rsp)
}

// CreateDialogWithBodyWithResponse request with arbitrary body returning *CreateDialogResp
func (c *ClientWithResponses) CreateDialogWithBodyWithResponse(ctx context.Context, chatId ChatIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDialogResp, error) {
	rsp, err := c.CreateDialogWithBody(ctx, chatId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDialogResp(rsp)
}

func (c *ClientWithResponses) CreateDialogWithResponse(ctx context.Context, chatId ChatIdPath, body CreateDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDialogResp, error) {
	rsp, err := c.CreateDialog(ctx, chatId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDialogResp(rsp)
}

// ListCustomersWithResponse request returning *ListCustomersResp
func (c *ClientWithResponses) ListCustomersWithResponse(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*ListCustomersResp, error) {
	rsp, err := c.ListCustomers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomersResp(rsp)
}

// ListDialogsWithResponse request returning *ListDialogsResp
func (c *ClientWithResponses) ListDialogsWithResponse(ctx context.Context, params *ListDialogsParams, reqEditors ...RequestEditorFn) (*ListDialogsResp, error) {
	rsp, err := c.ListDialogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDialogsResp(rsp)
}

// AssignDialogResponsibleWithBodyWithResponse request with arbitrary body returning *AssignDialogResponsibleResp
func (c *ClientWithResponses) AssignDialogResponsibleWithBodyWithResponse(ctx context.Context, dialogId DialogIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignDialogResponsibleResp, error) {
	rsp, err := c.AssignDialogResponsibleWithBody(ctx, dialogId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignDialogResponsibleResp(rsp)
}

func (c *ClientWithResponses) AssignDialogResponsibleWithResponse(ctx context.Context, dialogId DialogIdPath, body AssignDialogResponsibleJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignDialogResponsibleResp, error) {
	rsp, err := c.AssignDialogResponsible(ctx, dialogId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignDialogResponsibleResp(rsp)
}

// CloseDialogWithResponse request returning *CloseDialogResp
func (c *ClientWithResponses) CloseDialogWithResponse(ctx context.Context, dialogId DialogIdPath, reqEditors ...RequestEditorFn) (*CloseDialogResp, error) {
	rsp, err := c.CloseDialog(ctx, dialogId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloseDialogResp(rsp)
}

// DialogAddTagsWithBodyWithResponse request with arbitrary body returning *DialogAddTagsResp
func (c *ClientWithResponses) DialogAddTagsWithBodyWithResponse(ctx context.Context, dialogId DialogIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DialogAddTagsResp, error) {
	rsp, err := c.DialogAddTagsWithBody(ctx, dialogId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDialogAddTagsResp(rsp)
}

func (c *ClientWithResponses) DialogAddTagsWithResponse(ctx context.Context, dialogId DialogIdPath, body DialogAddTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DialogAddTagsResp, error) {
	rsp, err := c.DialogAddTags(ctx, dialogId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDialogAddTagsResp(rsp)
}

// DialogDeleteTagsWithBodyWithResponse request with arbitrary body returning *DialogDeleteTagsResp
func (c *ClientWithResponses) DialogDeleteTagsWithBodyWithResponse(ctx context.Context, dialogId DialogIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DialogDeleteTagsResp, error) {
	rsp, err := c.DialogDeleteTagsWithBody(ctx, dialogId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDialogDeleteTagsResp(rsp)
}

func (c *ClientWithResponses) DialogDeleteTagsWithResponse(ctx context.Context, dialogId DialogIdPath, body DialogDeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DialogDeleteTagsResp, error) {
	rsp, err := c.DialogDeleteTags(ctx, dialogId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDialogDeleteTagsResp(rsp)
}

// UnassignDialogResponsibleWithResponse request returning *UnassignDialogResponsibleResp
func (c *ClientWithResponses) UnassignDialogResponsibleWithResponse(ctx context.Context, dialogId DialogIdPath, reqEditors ...RequestEditorFn) (*UnassignDialogResponsibleResp, error) {
	rsp, err := c.UnassignDialogResponsible(ctx, dialogId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignDialogResponsibleResp(rsp)
}

// UploadFileWithBodyWithResponse request with arbitrary body returning *UploadFileResp
func (c *ClientWithResponses) UploadFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileResp, error) {
	rsp, err := c.UploadFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileResp(rsp)
}

// UploadFileByUrlWithBodyWithResponse request with arbitrary body returning *UploadFileByUrlResp
func (c *ClientWithResponses) UploadFileByUrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileByUrlResp, error) {
	rsp, err := c.UploadFileByUrlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileByUrlResp(rsp)
}

func (c *ClientWithResponses) UploadFileByUrlWithResponse(ctx context.Context, body UploadFileByUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadFileByUrlResp, error) {
	rsp, err := c.UploadFileByUrl(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileByUrlResp(rsp)
}

// GetFileUrlWithResponse request returning *GetFileUrlResp
func (c *ClientWithResponses) GetFileUrlWithResponse(ctx context.Context, id FileIdPath, reqEditors ...RequestEditorFn) (*GetFileUrlResp, error) {
	rsp, err := c.GetFileUrl(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileUrlResp(rsp)
}

// UpdateFileMetadataWithBodyWithResponse request with arbitrary body returning *UpdateFileMetadataResp
func (c *ClientWithResponses) UpdateFileMetadataWithBodyWithResponse(ctx context.Context, id FileIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFileMetadataResp, error) {
	rsp, err := c.UpdateFileMetadataWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFileMetadataResp(rsp)
}

func (c *ClientWithResponses) UpdateFileMetadataWithResponse(ctx context.Context, id FileIdPath, body UpdateFileMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFileMetadataResp, error) {
	rsp, err := c.UpdateFileMetadata(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFileMetadataResp(rsp)
}

// ListMembersWithResponse request returning *ListMembersResp
func (c *ClientWithResponses) ListMembersWithResponse(ctx context.Context, params *ListMembersParams, reqEditors ...RequestEditorFn) (*ListMembersResp, error) {
	rsp, err := c.ListMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMembersResp(rsp)
}

// ListMessagesWithResponse request returning *ListMessagesResp
func (c *ClientWithResponses) ListMessagesWithResponse(ctx context.Context, params *ListMessagesParams, reqEditors ...RequestEditorFn) (*ListMessagesResp, error) {
	rsp, err := c.ListMessages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMessagesResp(rsp)
}

// SendMessageWithBodyWithResponse request with arbitrary body returning *SendMessageResp
func (c *ClientWithResponses) SendMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMessageResp, error) {
	rsp, err := c.SendMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageResp(rsp)
}

func (c *ClientWithResponses) SendMessageWithResponse(ctx context.Context, body SendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageResp, error) {
	rsp, err := c.SendMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageResp(rsp)
}

// DeleteMessageWithResponse request returning *DeleteMessageResp
func (c *ClientWithResponses) DeleteMessageWithResponse(ctx context.Context, messageId MessageIdPath, reqEditors ...RequestEditorFn) (*DeleteMessageResp, error) {
	rsp, err := c.DeleteMessage(ctx, messageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMessageResp(rsp)
}

// EditMessageWithBodyWithResponse request with arbitrary body returning *EditMessageResp
func (c *ClientWithResponses) EditMessageWithBodyWithResponse(ctx context.Context, messageId MessageIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditMessageResp, error) {
	rsp, err := c.EditMessageWithBody(ctx, messageId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditMessageResp(rsp)
}

func (c *ClientWithResponses) EditMessageWithResponse(ctx context.Context, messageId MessageIdPath, body EditMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*EditMessageResp, error) {
	rsp, err := c.EditMessage(ctx, messageId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditMessageResp(rsp)
}

// ListCommandsWithResponse request returning *ListCommandsResp
func (c *ClientWithResponses) ListCommandsWithResponse(ctx context.Context, params *ListCommandsParams, reqEditors ...RequestEditorFn) (*ListCommandsResp, error) {
	rsp, err := c.ListCommands(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCommandsResp(rsp)
}

// DeleteCommandWithResponse request returning *DeleteCommandResp
func (c *ClientWithResponses) DeleteCommandWithResponse(ctx context.Context, commandName CommandNamePath, reqEditors ...RequestEditorFn) (*DeleteCommandResp, error) {
	rsp, err := c.DeleteCommand(ctx, commandName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommandResp(rsp)
}

// CreateOrUpdateCommandWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateCommandResp
func (c *ClientWithResponses) CreateOrUpdateCommandWithBodyWithResponse(ctx context.Context, commandName CommandNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateCommandResp, error) {
	rsp, err := c.CreateOrUpdateCommandWithBody(ctx, commandName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateCommandResp(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateCommandWithResponse(ctx context.Context, commandName CommandNamePath, body CreateOrUpdateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateCommandResp, error) {
	rsp, err := c.CreateOrUpdateCommand(ctx, commandName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateCommandResp(rsp)
}

// UpdateBotWithBodyWithResponse request with arbitrary body returning *UpdateBotResp
func (c *ClientWithResponses) UpdateBotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBotResp, error) {
	rsp, err := c.UpdateBotWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBotResp(rsp)
}

func (c *ClientWithResponses) UpdateBotWithResponse(ctx context.Context, body UpdateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBotResp, error) {
	rsp, err := c.UpdateBot(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBotResp(rsp)
}

// ListUsersWithResponse request returning *ListUsersResp
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResp, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResp(rsp)
}

// WebSocketConnectionWithResponse request returning *WebSocketConnectionResp
func (c *ClientWithResponses) WebSocketConnectionWithResponse(ctx context.Context, params *WebSocketConnectionParams, reqEditors ...RequestEditorFn) (*WebSocketConnectionResp, error) {
	rsp, err := c.WebSocketConnection(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebSocketConnectionResp(rsp)
}

// ParseListBotsResp parses an HTTP response from a ListBotsWithResponse call
func ParseListBotsResp(rsp *http.Response) (*ListBotsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBotsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BotsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListChannelsResp parses an HTTP response from a ListChannelsWithResponse call
func ParseListChannelsResp(rsp *http.Response) (*ListChannelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListChannelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListChatsResp parses an HTTP response from a ListChatsWithResponse call
func ParseListChatsResp(rsp *http.Response) (*ListChatsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListChatsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDialogResp parses an HTTP response from a CreateDialogWithResponse call
func ParseCreateDialogResp(rsp *http.Response) (*CreateDialogResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDialogResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateDialogResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCustomersResp parses an HTTP response from a ListCustomersWithResponse call
func ParseListCustomersResp(rsp *http.Response) (*ListCustomersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomersListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListDialogsResp parses an HTTP response from a ListDialogsWithResponse call
func ParseListDialogsResp(rsp *http.Response) (*ListDialogsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDialogsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DialogsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssignDialogResponsibleResp parses an HTTP response from a AssignDialogResponsibleWithResponse call
func ParseAssignDialogResponsibleResp(rsp *http.Response) (*AssignDialogResponsibleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignDialogResponsibleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DialogAssignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCloseDialogResp parses an HTTP response from a CloseDialogWithResponse call
func ParseCloseDialogResp(rsp *http.Response) (*CloseDialogResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloseDialogResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDialogAddTagsResp parses an HTTP response from a DialogAddTagsWithResponse call
func ParseDialogAddTagsResp(rsp *http.Response) (*DialogAddTagsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DialogAddTagsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDialogDeleteTagsResp parses an HTTP response from a DialogDeleteTagsWithResponse call
func ParseDialogDeleteTagsResp(rsp *http.Response) (*DialogDeleteTagsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DialogDeleteTagsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnassignDialogResponsibleResp parses an HTTP response from a UnassignDialogResponsibleWithResponse call
func ParseUnassignDialogResponsibleResp(rsp *http.Response) (*UnassignDialogResponsibleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignDialogResponsibleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DialogUnassignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadFileResp parses an HTTP response from a UploadFileWithResponse call
func ParseUploadFileResp(rsp *http.Response) (*UploadFileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadFileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadFileByUrlResp parses an HTTP response from a UploadFileByUrlWithResponse call
func ParseUploadFileByUrlResp(rsp *http.Response) (*UploadFileByUrlResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadFileByUrlResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFileUrlResp parses an HTTP response from a GetFileUrlWithResponse call
func ParseGetFileUrlResp(rsp *http.Response) (*GetFileUrlResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileUrlResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FullFileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateFileMetadataResp parses an HTTP response from a UpdateFileMetadataWithResponse call
func ParseUpdateFileMetadataResp(rsp *http.Response) (*UpdateFileMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFileMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMembersResp parses an HTTP response from a ListMembersWithResponse call
func ParseListMembersResp(rsp *http.Response) (*ListMembersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMembersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatMemberListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMessagesResp parses an HTTP response from a ListMessagesWithResponse call
func ParseListMessagesResp(rsp *http.Response) (*ListMessagesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMessagesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendMessageResp parses an HTTP response from a SendMessageWithResponse call
func ParseSendMessageResp(rsp *http.Response) (*SendMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendMessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMessageResp parses an HTTP response from a DeleteMessageWithResponse call
func ParseDeleteMessageResp(rsp *http.Response) (*DeleteMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditMessageResp parses an HTTP response from a EditMessageWithResponse call
func ParseEditMessageResp(rsp *http.Response) (*EditMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCommandsResp parses an HTTP response from a ListCommandsWithResponse call
func ParseListCommandsResp(rsp *http.Response) (*ListCommandsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCommandsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCommandResp parses an HTTP response from a DeleteCommandWithResponse call
func ParseDeleteCommandResp(rsp *http.Response) (*DeleteCommandResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCommandResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateCommandResp parses an HTTP response from a CreateOrUpdateCommandWithResponse call
func ParseCreateOrUpdateCommandResp(rsp *http.Response) (*CreateOrUpdateCommandResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateCommandResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateBotResp parses an HTTP response from a UpdateBotWithResponse call
func ParseUpdateBotResp(rsp *http.Response) (*UpdateBotResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBotResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUsersResp parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResp(rsp *http.Response) (*ListUsersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseWebSocketConnectionResp parses an HTTP response from a WebSocketConnectionWithResponse call
func ParseWebSocketConnectionResp(rsp *http.Response) (*WebSocketConnectionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebSocketConnectionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 101:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON101 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
